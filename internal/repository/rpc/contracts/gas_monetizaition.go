// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// GasMonetizationMetaData contains all meta data concerning the GasMonetization contract.
var GasMonetizationMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sfcAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalEpochsFrequencyLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"confirmationsToMakeWithdrawal\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sfcAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalEpochsFrequencyLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"confirmationsToMakeWithdrawal\",\"type\":\"uint256\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalEpochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"diffAmount\",\"type\":\"uint256\"}],\"name\":\"InvalidWithdrawalAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardsRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"activeFromEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"ProjectAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ProjectContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ProjectContractRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"enabledOnEpochNumber\",\"type\":\"uint256\"}],\"name\":\"ProjectEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"}],\"name\":\"ProjectMetadataUriUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ProjectOwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ProjectRewardsRecipientUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"suspendedOnEpochNumber\",\"type\":\"uint256\"}],\"name\":\"ProjectSuspended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sfcAddress\",\"type\":\"address\"}],\"name\":\"SfcAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestEpochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalEpochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"WithdrawalConfirmationsLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"WithdrawalEpochsLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestEpochNumber\",\"type\":\"uint256\"}],\"name\":\"WithdrawalRequested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUNDER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUNDS_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROJECTS_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_DATA_PROVIDER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardsRecipient\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"addProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"addProjectContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"completeWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"enableProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"hasPendingWithdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"removeProjectContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"requestWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"suspendProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"}],\"name\":\"updateProjectMetadataUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"updateProjectOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"updateProjectRewardsRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sfc\",\"type\":\"address\"}],\"name\":\"updateSfcAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawalConfirmationsLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawalEpochsFrequencyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawAllFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x6080604052600060065560006007553480156200001b57600080fd5b5060405162002b2838038062002b288339810160408190526200003e916200016b565b600380546001600160a01b0319166001600160a01b03851617905560048290556005819055620000776000620000713390565b620000ca565b604080516001600160a01b0385168152602081018490529081018290527f841dc6a6c60372f7a25ab4e5cb947a19940954c4364b1badbc999dc6f57048689060600160405180910390a1505050620001b0565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1662000167576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620001263390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45b5050565b6000806000606084860312156200018157600080fd5b83516001600160a01b03811681146200019957600080fd5b602085015160409095015190969495509392505050565b61296880620001c06000396000f3fe6080604052600436106101bb5760003560e01c8063818fa6ce116100ec578063a217fddf1161008a578063c4707a8311610064578063c4707a8314610518578063c4d33f071461054c578063cbb9d8c91461056c578063d547741f1461058c57600080fd5b8063a217fddf146104db578063a26759cb146104f0578063c1075329146104f857600080fd5b806392cf316b116100c657806392cf316b146104475780639bfbca44146104675780639ee679e81461049b578063a210106f146104bb57600080fd5b8063818fa6ce146103e757806386350b751461040757806391d148541461042757600080fd5b806343ebc8c71161015957806366328a0a1161013357806366328a0a1461035857806369d1a186146103785780636bbd207c146103985780638098ac4c146103c757600080fd5b806343ebc8c7146102f6578063571e8697146103165780635fac2ba81461033857600080fd5b806332dee40b1161019557806332dee40b1461026257806334aedecd1461028257806334bfce4b146102b657806336568abe146102d657600080fd5b806301ffc9a7146101cf578063248a9ca3146102045780632f2ff15d1461024257600080fd5b366101ca576101c86105ac565b005b600080fd5b3480156101db57600080fd5b506101ef6101ea366004612049565b610728565b60405190151581526020015b60405180910390f35b34801561021057600080fd5b5061023461021f366004612073565b60009081526020819052604090206001015490565b6040519081526020016101fb565b34801561024e57600080fd5b506101c861025d3660046120a1565b61075f565b34801561026e57600080fd5b506101c861027d3660046120d1565b610789565b34801561028e57600080fd5b506102347f4f506ac322e467a10b006ee5ecfc5b7781c5c43d2ffbc468de868900d27b994581565b3480156102c257600080fd5b506101c86102d13660046120a1565b61082a565b3480156102e257600080fd5b506101c86102f13660046120a1565b6108ef565b34801561030257600080fd5b506101c86103113660046120ee565b61096d565b34801561032257600080fd5b5061023460008051602061291383398151915281565b34801561034457600080fd5b506101c8610353366004612073565b610d94565b34801561036457600080fd5b506101c86103733660046120a1565b610df7565b34801561038457600080fd5b506101c8610393366004612073565b610edb565b3480156103a457600080fd5b506101ef6103b336600461211a565b600091825260086020526040909120541490565b3480156103d357600080fd5b506101c86103e2366004612185565b611073565b3480156103f357600080fd5b506101c8610402366004612073565b611154565b34801561041357600080fd5b506101c86104223660046121d1565b6112e4565b34801561043357600080fd5b506101ef6104423660046120a1565b6115e4565b34801561045357600080fd5b506101c86104623660046120a1565b61160d565b34801561047357600080fd5b506102347fb7afb381c2ec32313122d8bf9a9482db2de1a2e999efd75492ca6194dae14f3d81565b3480156104a757600080fd5b506101c86104b6366004612073565b6116de565b3480156104c757600080fd5b506101c86104d6366004612073565b611986565b3480156104e757600080fd5b50610234600081565b6101c86105ac565b34801561050457600080fd5b506101c8610513366004612295565b6119e1565b34801561052457600080fd5b506102347f93779bf6be703205517715c86297c193472c9d5533e90609b671022041168a4c81565b34801561055857600080fd5b506101c86105673660046120a1565b611a3a565b34801561057857600080fd5b506101c86105873660046120d1565b611b60565b34801561059857600080fd5b506101c86105a73660046120a1565b611bd5565b6105d67f4f506ac322e467a10b006ee5ecfc5b7781c5c43d2ffbc468de868900d27b9945336115e4565b6106275760405162461bcd60e51b815260206004820152601b60248201527f4761734d6f6e6574697a6174696f6e3a206e6f742066756e646572000000000060448201526064015b60405180910390fd5b600034116106775760405162461bcd60e51b815260206004820152601e60248201527f4761734d6f6e6574697a6174696f6e3a206e6f2066756e64732073656e740000604482015260640161061e565b600360009054906101000a90046001600160a01b03166001600160a01b031663766718086040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106ca573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ee91906122c1565b60075560405134815233907f8fe10ae416f22f5e5220b0018a6c1d4ff534d6aa3a471f2a20cb7747fe63e5b99060200160405180910390a2565b60006001600160e01b03198216637965db0b60e01b148061075957506301ffc9a760e01b6001600160e01b03198316145b92915050565b60008281526020819052604090206001015461077a81611bfa565b6107848383611c07565b505050565b6107b37f93779bf6be703205517715c86297c193472c9d5533e90609b671022041168a4c336115e4565b6107cf5760405162461bcd60e51b815260040161061e906122da565b476107e36001600160a01b03831682611c8b565b816001600160a01b03167feaff4b37086828766ad3268786972c0cd24259d4c87a80f9d3963a3c3d999b0d8260405161081e91815260200190565b60405180910390a25050565b610842600080516020612913833981519152336115e4565b61085e5760405162461bcd60e51b815260040161061e9061231c565b6000828152600160205260409020546001600160a01b03166108925760405162461bcd60e51b815260040161061e90612361565b60008281526001602090815260409182902080546001600160a01b0319166001600160a01b038516908117909155915191825283917fffc579e983741c17a95792c458e2ae8c933b1bf7f5cd84f3bca571505c25d42a910161081e565b6001600160a01b038116331461095f5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b606482015260840161061e565b6109698282611da4565b5050565b6109977fb7afb381c2ec32313122d8bf9a9482db2de1a2e999efd75492ca6194dae14f3d336115e4565b6109f65760405162461bcd60e51b815260206004820152602a60248201527f4761734d6f6e6574697a6174696f6e3a206e6f742072657761726473206461746044820152693090383937bb34b232b960b11b606482015260840161061e565b6000838152600860205260409020548214610a625760405162461bcd60e51b815260206004820152602660248201527f4761734d6f6e6574697a6174696f6e3a206e6f207769746864726177616c2072604482015265195c5d595cdd60d21b606482015260840161061e565b60008111610ac15760405162461bcd60e51b815260206004820152602660248201527f4761734d6f6e6574697a6174696f6e3a206e6f20616d6f756e7420746f20776960448201526574686472617760d01b606482015260840161061e565b60008381526008602052604081206001810154909103610ae75760028101829055610b71565b81816002015414610b71576002810154604080518581526020810192909252810183905284907fe13f2d157714b016f2b9ff3d2db5002bca0925cf357170d6ab0bd1867ce6880b9060600160405180910390a26000848152600860205260408120818155600181018290556002810182905590610b676003830182612017565b5050919091555050565b60005b6003820154811015610c1b57336001600160a01b0316826003018281548110610b9f57610b9f6123a8565b6000918252602090912001546001600160a01b031603610c0b5760405162461bcd60e51b815260206004820152602160248201527f4761734d6f6e6574697a6174696f6e3a20616c72656164792070726f766964656044820152601960fa1b606482015260840161061e565b610c14816123d4565b9050610b74565b506003810180546001808201835560009283526020832090910180546001600160a01b031916331790558201805491610c53836123d4565b9190505550600554816001015410610d8e576000848152600860205260408120818155600181018290556002810182905590610c926003830182612017565b5050600360009054906101000a90046001600160a01b03166001600160a01b031663766718086040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ce7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d0b91906122c1565b600085815260016020819052604090912060038101929092550154610d39906001600160a01b031683611c8b565b6000848152600160209081526040918290206003015482518681529182015290810183905284907f709b466596e79834da0e8ee56d4624cb3e8464a18cd5ae894790b672594c402c9060600160405180910390a25b50505050565b610d9f6000336115e4565b610dbb5760405162461bcd60e51b815260040161061e906123ed565b60048190556040518181527fcb570b7d503f0243c8b8d03ebe2eb0c7cbd366a3a96a1560a936d8b373019ff4906020015b60405180910390a150565b610e0f600080516020612913833981519152336115e4565b610e2b5760405162461bcd60e51b815260040161061e9061231c565b6000828152600160205260409020546001600160a01b0316610e5f5760405162461bcd60e51b815260040161061e90612361565b6001600160a01b03811660009081526002602052604090205415610e955760405162461bcd60e51b815260040161061e90612424565b6001600160a01b0381166000818152600260205260408082208590555184917ff83ba82192ce64f0fd48145ca2b60956a005a2d4e28f14fb099fad71294b8ff391a35050565b610ef3600080516020612913833981519152336115e4565b610f0f5760405162461bcd60e51b815260040161061e9061231c565b6000818152600160205260409020546001600160a01b0316610f435760405162461bcd60e51b815260040161061e90612361565b6000818152600160205260408120600501549003610fa35760405162461bcd60e51b815260206004820152601f60248201527f4761734d6f6e6574697a6174696f6e3a2070726f6a6563742061637469766500604482015260640161061e565b600360009054906101000a90046001600160a01b03166001600160a01b031663766718086040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ff6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061101a91906122c1565b60008281526001602052604080822060048101849055600501919091555182917f0737ed2cc6eb4cf4aefb6d1e1404305301a64cae58ccf508828a20412fb77f359161106891815260200190565b60405180910390a250565b61108b600080516020612913833981519152336115e4565b6110a75760405162461bcd60e51b815260040161061e9061231c565b6000838152600160205260409020546001600160a01b03166110db5760405162461bcd60e51b815260040161061e90612361565b806110f85760405162461bcd60e51b815260040161061e90612470565b6000838152600160205260409020600201611114828483612551565b50827f781779743e625d6e652139cabc7e7c736ad376a0f1302b1b5c346548d948c72e8383604051611147929190612612565b60405180910390a2505050565b61116c600080516020612913833981519152336115e4565b6111885760405162461bcd60e51b815260040161061e9061231c565b6000818152600160205260409020546001600160a01b03166111bc5760405162461bcd60e51b815260040161061e90612361565b600081815260016020526040902060050154156112265760405162461bcd60e51b815260206004820152602260248201527f4761734d6f6e6574697a6174696f6e3a2070726f6a6563742073757370656e64604482015261195960f21b606482015260840161061e565b600360009054906101000a90046001600160a01b03166001600160a01b031663766718086040518163ffffffff1660e01b8152600401602060405180830381865afa158015611279573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061129d91906122c1565b600082815260016020526040908190206005018290555182917f0c3ad6c6f2fc1e970caed51e87ac06c3a37569f33664f42771264a4ae89078229161106891815260200190565b6112fc600080516020612913833981519152336115e4565b6113185760405162461bcd60e51b815260040161061e9061231c565b826113355760405162461bcd60e51b815260040161061e90612470565b60068054906000611345836123d4565b91905055506040518060c00160405280876001600160a01b03168152602001866001600160a01b0316815260200185858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525093855250505060208083019190915260035460408051630ecce30160e31b8152815191909401936001600160a01b0390921692637667180892600480820193918290030181865afa1580156113fe573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061142291906122c1565b81526000602091820181905260065481526001808352604091829020845181546001600160a01b03199081166001600160a01b0392831617835594860151928201805490951692169190911790925582015160028201906114839082612641565b50606082015160038201556080820151600482015560a09091015160059091015560005b8181101561156957600260008484848181106114c5576114c56123a8565b90506020020160208101906114da91906120d1565b6001600160a01b03168152602081019190915260400160002054156115115760405162461bcd60e51b815260040161061e90612424565b6006546002600085858581811061152a5761152a6123a8565b905060200201602081019061153f91906120d1565b6001600160a01b03168152602081019190915260400160002055611562816123d4565b90506114a7565b50600654600081815260016020819052604091829020908101548154600483015493516001600160a01b0392831695929091169391927fa8f2a13a6c4c221e863c34b0174b2a8356551bc645dc295ae4b5796c240915aa926115d4926002909201918990899061274a565b60405180910390a4505050505050565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b6000828152600160205260409020546001600160a01b0316331461167e5760405162461bcd60e51b815260206004820152602260248201527f4761734d6f6e6574697a6174696f6e3a206e6f742070726f6a656374206f776e60448201526132b960f11b606482015260840161061e565b60008281526001602081815260409283902090910180546001600160a01b0319166001600160a01b038516908117909155915191825283917fc96c5102d284d786d29b5d0d7dda6ce493724355b762993adfef62b7220f161c910161081e565b6000818152600160205260409020546001600160a01b031633146117445760405162461bcd60e51b815260206004820152601a60248201527f4761734d6f6e6574697a6174696f6e3a206e6f74206f776e6572000000000000604482015260640161061e565b600081815260086020526040902054156117b05760405162461bcd60e51b815260206004820152602760248201527f4761734d6f6e6574697a6174696f6e3a206861732070656e64696e67207769746044820152661a191c985dd85b60ca1b606482015260840161061e565b60008181526001602052604090206005015415806117e4575060008181526001602052604090206005810154600390910154105b61183a5760405162461bcd60e51b815260206004820152602160248201527f4761734d6f6e6574697a6174696f6e3a2070726f6a6563742064697361626c656044820152601960fa1b606482015260840161061e565b60035460408051630ecce30160e31b815290516000926001600160a01b03169163766718089160048083019260209291908290030181865afa158015611884573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118a891906122c1565b60008381526001602052604090206003015460075491925090158015906118d0575060075481105b80156118e657506004546118e482846127f2565b115b6119415760405162461bcd60e51b815260206004820152602660248201527f4761734d6f6e6574697a6174696f6e3a206d757374207761697420746f20776960448201526574686472617760d01b606482015260840161061e565b600083815260086020526040908190208390555183907f6b19bb08027e5bee64cbe3f99bbbfb671c0e134643993f0ad046fd01d020b342906111479085815260200190565b6119916000336115e4565b6119ad5760405162461bcd60e51b815260040161061e906123ed565b60058190556040518181527e209f2b72d564f415b7b96764fdee7ecf5f45854745e582a224b9a1a1ba1ddc90602001610dec565b611a0b7f93779bf6be703205517715c86297c193472c9d5533e90609b671022041168a4c336115e4565b611a275760405162461bcd60e51b815260040161061e906122da565b6107e36001600160a01b03831682611c8b565b611a52600080516020612913833981519152336115e4565b611a6e5760405162461bcd60e51b815260040161061e9061231c565b6000828152600160205260409020546001600160a01b0316611aa25760405162461bcd60e51b815260040161061e90612361565b6001600160a01b0381166000908152600260205260409020548214611b1a5760405162461bcd60e51b815260206004820152602860248201527f4761734d6f6e6574697a6174696f6e3a20636f6e7472616374206e6f7420726560448201526719da5cdd195c995960c21b606482015260840161061e565b6001600160a01b0381166000818152600260205260408082208290555184917fd32f2e923c29ff9e7231f459d69add67f769d05c5069c23bbdea536fc0cf154a91a35050565b611b6b6000336115e4565b611b875760405162461bcd60e51b815260040161061e906123ed565b600380546001600160a01b0319166001600160a01b0383169081179091556040519081527f620e7fb0cccb30fce2c95f32e301054c7ba7fd3520a8f42891915c9d10efe95f90602001610dec565b600082815260208190526040902060010154611bf081611bfa565b6107848383611da4565b611c048133611e09565b50565b611c1182826115e4565b610969576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055611c473390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b80471015611cdb5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e6365000000604482015260640161061e565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114611d28576040519150601f19603f3d011682016040523d82523d6000602084013e611d2d565b606091505b50509050806107845760405162461bcd60e51b815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d61792068617665207265766572746564000000000000606482015260840161061e565b611dae82826115e4565b15610969576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b611e1382826115e4565b61096957611e2081611e62565b611e2b836020611e74565b604051602001611e3c929190612829565b60408051601f198184030181529082905262461bcd60e51b825261061e9160040161289e565b60606107596001600160a01b03831660145b60606000611e838360026128d1565b611e8e9060026128e8565b67ffffffffffffffff811115611ea657611ea66124b3565b6040519080825280601f01601f191660200182016040528015611ed0576020820181803683370190505b509050600360fc1b81600081518110611eeb57611eeb6123a8565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110611f1a57611f1a6123a8565b60200101906001600160f81b031916908160001a9053506000611f3e8460026128d1565b611f499060016128e8565b90505b6001811115611fc1576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110611f7d57611f7d6123a8565b1a60f81b828281518110611f9357611f936123a8565b60200101906001600160f81b031916908160001a90535060049490941c93611fba816128fb565b9050611f4c565b5083156120105760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e74604482015260640161061e565b9392505050565b5080546000825590600052602060002090810190611c0491905b808211156120455760008155600101612031565b5090565b60006020828403121561205b57600080fd5b81356001600160e01b03198116811461201057600080fd5b60006020828403121561208557600080fd5b5035919050565b6001600160a01b0381168114611c0457600080fd5b600080604083850312156120b457600080fd5b8235915060208301356120c68161208c565b809150509250929050565b6000602082840312156120e357600080fd5b81356120108161208c565b60008060006060848603121561210357600080fd5b505081359360208301359350604090920135919050565b6000806040838503121561212d57600080fd5b50508035926020909101359150565b60008083601f84011261214e57600080fd5b50813567ffffffffffffffff81111561216657600080fd5b60208301915083602082850101111561217e57600080fd5b9250929050565b60008060006040848603121561219a57600080fd5b83359250602084013567ffffffffffffffff8111156121b857600080fd5b6121c48682870161213c565b9497909650939450505050565b600080600080600080608087890312156121ea57600080fd5b86356121f58161208c565b955060208701356122058161208c565b9450604087013567ffffffffffffffff8082111561222257600080fd5b61222e8a838b0161213c565b9096509450606089013591508082111561224757600080fd5b818901915089601f83011261225b57600080fd5b81358181111561226a57600080fd5b8a60208260051b850101111561227f57600080fd5b6020830194508093505050509295509295509295565b600080604083850312156122a857600080fd5b82356122b38161208c565b946020939093013593505050565b6000602082840312156122d357600080fd5b5051919050565b60208082526022908201527f4761734d6f6e6574697a6174696f6e3a206e6f742066756e6473206d616e616760408201526132b960f11b606082015260800190565b60208082526025908201527f4761734d6f6e6574697a6174696f6e3a206e6f742070726f6a65637473206d616040820152643730b3b2b960d91b606082015260800190565b60208082526027908201527f4761734d6f6e6574697a6174696f6e3a2070726f6a65637420646f6573206e6f6040820152661d08195e1a5cdd60ca1b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016123e6576123e66123be565b5060010190565b6020808252601a908201527f4761734d6f6e6574697a6174696f6e3a206e6f742061646d696e000000000000604082015260600190565b6020808252602c908201527f4761734d6f6e6574697a6174696f6e3a20636f6e747261637420616c7265616460408201526b1e481c9959da5cdd195c995960a21b606082015260800190565b60208082526023908201527f4761734d6f6e6574697a6174696f6e3a20656d707479206d657461646174612060408201526275726960e81b606082015260800190565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806124dd57607f821691505b6020821081036124fd57634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561078457600081815260208120601f850160051c8101602086101561252a5750805b601f850160051c820191505b8181101561254957828155600101612536565b505050505050565b67ffffffffffffffff831115612569576125696124b3565b61257d8361257783546124c9565b83612503565b6000601f8411600181146125b157600085156125995750838201355b600019600387901b1c1916600186901b17835561260b565b600083815260209020601f19861690835b828110156125e257868501358255602094850194600190920191016125c2565b50868210156125ff5760001960f88860031b161c19848701351681555b505060018560011b0183555b5050505050565b60208152816020820152818360408301376000818301604090810191909152601f909201601f19160101919050565b815167ffffffffffffffff81111561265b5761265b6124b3565b61266f8161266984546124c9565b84612503565b602080601f8311600181146126a4576000841561268c5750858301515b600019600386901b1c1916600185901b178555612549565b600085815260208120601f198616915b828110156126d3578886015182559484019460019091019084016126b4565b50858210156126f15787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b8183526000602080850194508260005b8581101561273f5781356127248161208c565b6001600160a01b031687529582019590820190600101612711565b509495945050505050565b60608152600080865461275c816124c9565b806060860152608060018084166000811461277e5760018114612798576127c9565b60ff1985168884015283151560051b8801830195506127c9565b8b60005260208060002060005b868110156127c05781548b82018701529084019082016127a5565b8a018501975050505b505050505085602084015282810360408401526127e7818587612701565b979650505050505050565b81810381811115610759576107596123be565b60005b83811015612820578181015183820152602001612808565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351612861816017850160208801612805565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351612892816028840160208801612805565b01602801949350505050565b60208152600082518060208401526128bd816040850160208701612805565b601f01601f19169190910160400192915050565b8082028115828204841417610759576107596123be565b80820180821115610759576107596123be565b60008161290a5761290a6123be565b50600019019056fe979b77ba2fd37b608c52b1185e9b8e96ba2ff2e0c1dff47d2959620ef0ab3861a26469706673582212200485d07251cda3d11a70c796f0a6c34eee33f89f502d1627df9ae0d3425505a564736f6c63430008130033",
}

// GasMonetizationABI is the input ABI used to generate the binding from.
// Deprecated: Use GasMonetizationMetaData.ABI instead.
var GasMonetizationABI = GasMonetizationMetaData.ABI

// GasMonetizationBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use GasMonetizationMetaData.Bin instead.
var GasMonetizationBin = GasMonetizationMetaData.Bin

// DeployGasMonetization deploys a new Ethereum contract, binding an instance of GasMonetization to it.
func DeployGasMonetization(auth *bind.TransactOpts, backend bind.ContractBackend, sfcAddress common.Address, withdrawalEpochsFrequencyLimit *big.Int, confirmationsToMakeWithdrawal *big.Int) (common.Address, *types.Transaction, *GasMonetization, error) {
	parsed, err := GasMonetizationMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(GasMonetizationBin), backend, sfcAddress, withdrawalEpochsFrequencyLimit, confirmationsToMakeWithdrawal)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &GasMonetization{GasMonetizationCaller: GasMonetizationCaller{contract: contract}, GasMonetizationTransactor: GasMonetizationTransactor{contract: contract}, GasMonetizationFilterer: GasMonetizationFilterer{contract: contract}}, nil
}

// GasMonetization is an auto generated Go binding around an Ethereum contract.
type GasMonetization struct {
	GasMonetizationCaller     // Read-only binding to the contract
	GasMonetizationTransactor // Write-only binding to the contract
	GasMonetizationFilterer   // Log filterer for contract events
}

// GasMonetizationCaller is an auto generated read-only Go binding around an Ethereum contract.
type GasMonetizationCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// GasMonetizationTransactor is an auto generated write-only Go binding around an Ethereum contract.
type GasMonetizationTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// GasMonetizationFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type GasMonetizationFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// GasMonetizationSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type GasMonetizationSession struct {
	Contract     *GasMonetization  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// GasMonetizationCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type GasMonetizationCallerSession struct {
	Contract *GasMonetizationCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// GasMonetizationTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type GasMonetizationTransactorSession struct {
	Contract     *GasMonetizationTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// GasMonetizationRaw is an auto generated low-level Go binding around an Ethereum contract.
type GasMonetizationRaw struct {
	Contract *GasMonetization // Generic contract binding to access the raw methods on
}

// GasMonetizationCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type GasMonetizationCallerRaw struct {
	Contract *GasMonetizationCaller // Generic read-only contract binding to access the raw methods on
}

// GasMonetizationTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type GasMonetizationTransactorRaw struct {
	Contract *GasMonetizationTransactor // Generic write-only contract binding to access the raw methods on
}

// NewGasMonetization creates a new instance of GasMonetization, bound to a specific deployed contract.
func NewGasMonetization(address common.Address, backend bind.ContractBackend) (*GasMonetization, error) {
	contract, err := bindGasMonetization(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &GasMonetization{GasMonetizationCaller: GasMonetizationCaller{contract: contract}, GasMonetizationTransactor: GasMonetizationTransactor{contract: contract}, GasMonetizationFilterer: GasMonetizationFilterer{contract: contract}}, nil
}

// NewGasMonetizationCaller creates a new read-only instance of GasMonetization, bound to a specific deployed contract.
func NewGasMonetizationCaller(address common.Address, caller bind.ContractCaller) (*GasMonetizationCaller, error) {
	contract, err := bindGasMonetization(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationCaller{contract: contract}, nil
}

// NewGasMonetizationTransactor creates a new write-only instance of GasMonetization, bound to a specific deployed contract.
func NewGasMonetizationTransactor(address common.Address, transactor bind.ContractTransactor) (*GasMonetizationTransactor, error) {
	contract, err := bindGasMonetization(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationTransactor{contract: contract}, nil
}

// NewGasMonetizationFilterer creates a new log filterer instance of GasMonetization, bound to a specific deployed contract.
func NewGasMonetizationFilterer(address common.Address, filterer bind.ContractFilterer) (*GasMonetizationFilterer, error) {
	contract, err := bindGasMonetization(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationFilterer{contract: contract}, nil
}

// bindGasMonetization binds a generic wrapper to an already deployed contract.
func bindGasMonetization(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := GasMonetizationMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_GasMonetization *GasMonetizationRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _GasMonetization.Contract.GasMonetizationCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_GasMonetization *GasMonetizationRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasMonetization.Contract.GasMonetizationTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_GasMonetization *GasMonetizationRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _GasMonetization.Contract.GasMonetizationTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_GasMonetization *GasMonetizationCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _GasMonetization.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_GasMonetization *GasMonetizationTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasMonetization.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_GasMonetization *GasMonetizationTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _GasMonetization.Contract.contract.Transact(opts, method, params...)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "DEFAULT_ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _GasMonetization.Contract.DEFAULTADMINROLE(&_GasMonetization.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _GasMonetization.Contract.DEFAULTADMINROLE(&_GasMonetization.CallOpts)
}

// FUNDERROLE is a free data retrieval call binding the contract method 0x34aedecd.
//
// Solidity: function FUNDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) FUNDERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "FUNDER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// FUNDERROLE is a free data retrieval call binding the contract method 0x34aedecd.
//
// Solidity: function FUNDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) FUNDERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.FUNDERROLE(&_GasMonetization.CallOpts)
}

// FUNDERROLE is a free data retrieval call binding the contract method 0x34aedecd.
//
// Solidity: function FUNDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) FUNDERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.FUNDERROLE(&_GasMonetization.CallOpts)
}

// FUNDSMANAGERROLE is a free data retrieval call binding the contract method 0xc4707a83.
//
// Solidity: function FUNDS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) FUNDSMANAGERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "FUNDS_MANAGER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// FUNDSMANAGERROLE is a free data retrieval call binding the contract method 0xc4707a83.
//
// Solidity: function FUNDS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) FUNDSMANAGERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.FUNDSMANAGERROLE(&_GasMonetization.CallOpts)
}

// FUNDSMANAGERROLE is a free data retrieval call binding the contract method 0xc4707a83.
//
// Solidity: function FUNDS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) FUNDSMANAGERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.FUNDSMANAGERROLE(&_GasMonetization.CallOpts)
}

// PROJECTSMANAGERROLE is a free data retrieval call binding the contract method 0x571e8697.
//
// Solidity: function PROJECTS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) PROJECTSMANAGERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "PROJECTS_MANAGER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// PROJECTSMANAGERROLE is a free data retrieval call binding the contract method 0x571e8697.
//
// Solidity: function PROJECTS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) PROJECTSMANAGERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.PROJECTSMANAGERROLE(&_GasMonetization.CallOpts)
}

// PROJECTSMANAGERROLE is a free data retrieval call binding the contract method 0x571e8697.
//
// Solidity: function PROJECTS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) PROJECTSMANAGERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.PROJECTSMANAGERROLE(&_GasMonetization.CallOpts)
}

// REWARDSDATAPROVIDERROLE is a free data retrieval call binding the contract method 0x9bfbca44.
//
// Solidity: function REWARDS_DATA_PROVIDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) REWARDSDATAPROVIDERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "REWARDS_DATA_PROVIDER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// REWARDSDATAPROVIDERROLE is a free data retrieval call binding the contract method 0x9bfbca44.
//
// Solidity: function REWARDS_DATA_PROVIDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) REWARDSDATAPROVIDERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.REWARDSDATAPROVIDERROLE(&_GasMonetization.CallOpts)
}

// REWARDSDATAPROVIDERROLE is a free data retrieval call binding the contract method 0x9bfbca44.
//
// Solidity: function REWARDS_DATA_PROVIDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) REWARDSDATAPROVIDERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.REWARDSDATAPROVIDERROLE(&_GasMonetization.CallOpts)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _GasMonetization.Contract.GetRoleAdmin(&_GasMonetization.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _GasMonetization.Contract.GetRoleAdmin(&_GasMonetization.CallOpts, role)
}

// HasPendingWithdrawal is a free data retrieval call binding the contract method 0x6bbd207c.
//
// Solidity: function hasPendingWithdrawal(uint256 projectId, uint256 epochId) view returns(bool)
func (_GasMonetization *GasMonetizationCaller) HasPendingWithdrawal(opts *bind.CallOpts, projectId *big.Int, epochId *big.Int) (bool, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "hasPendingWithdrawal", projectId, epochId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasPendingWithdrawal is a free data retrieval call binding the contract method 0x6bbd207c.
//
// Solidity: function hasPendingWithdrawal(uint256 projectId, uint256 epochId) view returns(bool)
func (_GasMonetization *GasMonetizationSession) HasPendingWithdrawal(projectId *big.Int, epochId *big.Int) (bool, error) {
	return _GasMonetization.Contract.HasPendingWithdrawal(&_GasMonetization.CallOpts, projectId, epochId)
}

// HasPendingWithdrawal is a free data retrieval call binding the contract method 0x6bbd207c.
//
// Solidity: function hasPendingWithdrawal(uint256 projectId, uint256 epochId) view returns(bool)
func (_GasMonetization *GasMonetizationCallerSession) HasPendingWithdrawal(projectId *big.Int, epochId *big.Int) (bool, error) {
	return _GasMonetization.Contract.HasPendingWithdrawal(&_GasMonetization.CallOpts, projectId, epochId)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_GasMonetization *GasMonetizationCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_GasMonetization *GasMonetizationSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _GasMonetization.Contract.HasRole(&_GasMonetization.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_GasMonetization *GasMonetizationCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _GasMonetization.Contract.HasRole(&_GasMonetization.CallOpts, role, account)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_GasMonetization *GasMonetizationCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_GasMonetization *GasMonetizationSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _GasMonetization.Contract.SupportsInterface(&_GasMonetization.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_GasMonetization *GasMonetizationCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _GasMonetization.Contract.SupportsInterface(&_GasMonetization.CallOpts, interfaceId)
}

// AddFunds is a paid mutator transaction binding the contract method 0xa26759cb.
//
// Solidity: function addFunds() payable returns()
func (_GasMonetization *GasMonetizationTransactor) AddFunds(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "addFunds")
}

// AddFunds is a paid mutator transaction binding the contract method 0xa26759cb.
//
// Solidity: function addFunds() payable returns()
func (_GasMonetization *GasMonetizationSession) AddFunds() (*types.Transaction, error) {
	return _GasMonetization.Contract.AddFunds(&_GasMonetization.TransactOpts)
}

// AddFunds is a paid mutator transaction binding the contract method 0xa26759cb.
//
// Solidity: function addFunds() payable returns()
func (_GasMonetization *GasMonetizationTransactorSession) AddFunds() (*types.Transaction, error) {
	return _GasMonetization.Contract.AddFunds(&_GasMonetization.TransactOpts)
}

// AddProject is a paid mutator transaction binding the contract method 0x86350b75.
//
// Solidity: function addProject(address owner, address rewardsRecipient, string metadataUri, address[] contracts) returns()
func (_GasMonetization *GasMonetizationTransactor) AddProject(opts *bind.TransactOpts, owner common.Address, rewardsRecipient common.Address, metadataUri string, contracts []common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "addProject", owner, rewardsRecipient, metadataUri, contracts)
}

// AddProject is a paid mutator transaction binding the contract method 0x86350b75.
//
// Solidity: function addProject(address owner, address rewardsRecipient, string metadataUri, address[] contracts) returns()
func (_GasMonetization *GasMonetizationSession) AddProject(owner common.Address, rewardsRecipient common.Address, metadataUri string, contracts []common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.AddProject(&_GasMonetization.TransactOpts, owner, rewardsRecipient, metadataUri, contracts)
}

// AddProject is a paid mutator transaction binding the contract method 0x86350b75.
//
// Solidity: function addProject(address owner, address rewardsRecipient, string metadataUri, address[] contracts) returns()
func (_GasMonetization *GasMonetizationTransactorSession) AddProject(owner common.Address, rewardsRecipient common.Address, metadataUri string, contracts []common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.AddProject(&_GasMonetization.TransactOpts, owner, rewardsRecipient, metadataUri, contracts)
}

// AddProjectContract is a paid mutator transaction binding the contract method 0x66328a0a.
//
// Solidity: function addProjectContract(uint256 projectId, address contractAddress) returns()
func (_GasMonetization *GasMonetizationTransactor) AddProjectContract(opts *bind.TransactOpts, projectId *big.Int, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "addProjectContract", projectId, contractAddress)
}

// AddProjectContract is a paid mutator transaction binding the contract method 0x66328a0a.
//
// Solidity: function addProjectContract(uint256 projectId, address contractAddress) returns()
func (_GasMonetization *GasMonetizationSession) AddProjectContract(projectId *big.Int, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.AddProjectContract(&_GasMonetization.TransactOpts, projectId, contractAddress)
}

// AddProjectContract is a paid mutator transaction binding the contract method 0x66328a0a.
//
// Solidity: function addProjectContract(uint256 projectId, address contractAddress) returns()
func (_GasMonetization *GasMonetizationTransactorSession) AddProjectContract(projectId *big.Int, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.AddProjectContract(&_GasMonetization.TransactOpts, projectId, contractAddress)
}

// CompleteWithdrawal is a paid mutator transaction binding the contract method 0x43ebc8c7.
//
// Solidity: function completeWithdrawal(uint256 projectId, uint256 epochNumber, uint256 amount) returns()
func (_GasMonetization *GasMonetizationTransactor) CompleteWithdrawal(opts *bind.TransactOpts, projectId *big.Int, epochNumber *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "completeWithdrawal", projectId, epochNumber, amount)
}

// CompleteWithdrawal is a paid mutator transaction binding the contract method 0x43ebc8c7.
//
// Solidity: function completeWithdrawal(uint256 projectId, uint256 epochNumber, uint256 amount) returns()
func (_GasMonetization *GasMonetizationSession) CompleteWithdrawal(projectId *big.Int, epochNumber *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.CompleteWithdrawal(&_GasMonetization.TransactOpts, projectId, epochNumber, amount)
}

// CompleteWithdrawal is a paid mutator transaction binding the contract method 0x43ebc8c7.
//
// Solidity: function completeWithdrawal(uint256 projectId, uint256 epochNumber, uint256 amount) returns()
func (_GasMonetization *GasMonetizationTransactorSession) CompleteWithdrawal(projectId *big.Int, epochNumber *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.CompleteWithdrawal(&_GasMonetization.TransactOpts, projectId, epochNumber, amount)
}

// EnableProject is a paid mutator transaction binding the contract method 0x69d1a186.
//
// Solidity: function enableProject(uint256 projectId) returns()
func (_GasMonetization *GasMonetizationTransactor) EnableProject(opts *bind.TransactOpts, projectId *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "enableProject", projectId)
}

// EnableProject is a paid mutator transaction binding the contract method 0x69d1a186.
//
// Solidity: function enableProject(uint256 projectId) returns()
func (_GasMonetization *GasMonetizationSession) EnableProject(projectId *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.EnableProject(&_GasMonetization.TransactOpts, projectId)
}

// EnableProject is a paid mutator transaction binding the contract method 0x69d1a186.
//
// Solidity: function enableProject(uint256 projectId) returns()
func (_GasMonetization *GasMonetizationTransactorSession) EnableProject(projectId *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.EnableProject(&_GasMonetization.TransactOpts, projectId)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.GrantRole(&_GasMonetization.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.GrantRole(&_GasMonetization.TransactOpts, role, account)
}

// RemoveProjectContract is a paid mutator transaction binding the contract method 0xc4d33f07.
//
// Solidity: function removeProjectContract(uint256 projectId, address contractAddress) returns()
func (_GasMonetization *GasMonetizationTransactor) RemoveProjectContract(opts *bind.TransactOpts, projectId *big.Int, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "removeProjectContract", projectId, contractAddress)
}

// RemoveProjectContract is a paid mutator transaction binding the contract method 0xc4d33f07.
//
// Solidity: function removeProjectContract(uint256 projectId, address contractAddress) returns()
func (_GasMonetization *GasMonetizationSession) RemoveProjectContract(projectId *big.Int, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RemoveProjectContract(&_GasMonetization.TransactOpts, projectId, contractAddress)
}

// RemoveProjectContract is a paid mutator transaction binding the contract method 0xc4d33f07.
//
// Solidity: function removeProjectContract(uint256 projectId, address contractAddress) returns()
func (_GasMonetization *GasMonetizationTransactorSession) RemoveProjectContract(projectId *big.Int, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RemoveProjectContract(&_GasMonetization.TransactOpts, projectId, contractAddress)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "renounceRole", role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RenounceRole(&_GasMonetization.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactorSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RenounceRole(&_GasMonetization.TransactOpts, role, account)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0x9ee679e8.
//
// Solidity: function requestWithdrawal(uint256 projectId) returns()
func (_GasMonetization *GasMonetizationTransactor) RequestWithdrawal(opts *bind.TransactOpts, projectId *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "requestWithdrawal", projectId)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0x9ee679e8.
//
// Solidity: function requestWithdrawal(uint256 projectId) returns()
func (_GasMonetization *GasMonetizationSession) RequestWithdrawal(projectId *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.RequestWithdrawal(&_GasMonetization.TransactOpts, projectId)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0x9ee679e8.
//
// Solidity: function requestWithdrawal(uint256 projectId) returns()
func (_GasMonetization *GasMonetizationTransactorSession) RequestWithdrawal(projectId *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.RequestWithdrawal(&_GasMonetization.TransactOpts, projectId)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RevokeRole(&_GasMonetization.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RevokeRole(&_GasMonetization.TransactOpts, role, account)
}

// SuspendProject is a paid mutator transaction binding the contract method 0x818fa6ce.
//
// Solidity: function suspendProject(uint256 projectId) returns()
func (_GasMonetization *GasMonetizationTransactor) SuspendProject(opts *bind.TransactOpts, projectId *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "suspendProject", projectId)
}

// SuspendProject is a paid mutator transaction binding the contract method 0x818fa6ce.
//
// Solidity: function suspendProject(uint256 projectId) returns()
func (_GasMonetization *GasMonetizationSession) SuspendProject(projectId *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.SuspendProject(&_GasMonetization.TransactOpts, projectId)
}

// SuspendProject is a paid mutator transaction binding the contract method 0x818fa6ce.
//
// Solidity: function suspendProject(uint256 projectId) returns()
func (_GasMonetization *GasMonetizationTransactorSession) SuspendProject(projectId *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.SuspendProject(&_GasMonetization.TransactOpts, projectId)
}

// UpdateProjectMetadataUri is a paid mutator transaction binding the contract method 0x8098ac4c.
//
// Solidity: function updateProjectMetadataUri(uint256 projectId, string metadataUri) returns()
func (_GasMonetization *GasMonetizationTransactor) UpdateProjectMetadataUri(opts *bind.TransactOpts, projectId *big.Int, metadataUri string) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "updateProjectMetadataUri", projectId, metadataUri)
}

// UpdateProjectMetadataUri is a paid mutator transaction binding the contract method 0x8098ac4c.
//
// Solidity: function updateProjectMetadataUri(uint256 projectId, string metadataUri) returns()
func (_GasMonetization *GasMonetizationSession) UpdateProjectMetadataUri(projectId *big.Int, metadataUri string) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateProjectMetadataUri(&_GasMonetization.TransactOpts, projectId, metadataUri)
}

// UpdateProjectMetadataUri is a paid mutator transaction binding the contract method 0x8098ac4c.
//
// Solidity: function updateProjectMetadataUri(uint256 projectId, string metadataUri) returns()
func (_GasMonetization *GasMonetizationTransactorSession) UpdateProjectMetadataUri(projectId *big.Int, metadataUri string) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateProjectMetadataUri(&_GasMonetization.TransactOpts, projectId, metadataUri)
}

// UpdateProjectOwner is a paid mutator transaction binding the contract method 0x34bfce4b.
//
// Solidity: function updateProjectOwner(uint256 projectId, address owner) returns()
func (_GasMonetization *GasMonetizationTransactor) UpdateProjectOwner(opts *bind.TransactOpts, projectId *big.Int, owner common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "updateProjectOwner", projectId, owner)
}

// UpdateProjectOwner is a paid mutator transaction binding the contract method 0x34bfce4b.
//
// Solidity: function updateProjectOwner(uint256 projectId, address owner) returns()
func (_GasMonetization *GasMonetizationSession) UpdateProjectOwner(projectId *big.Int, owner common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateProjectOwner(&_GasMonetization.TransactOpts, projectId, owner)
}

// UpdateProjectOwner is a paid mutator transaction binding the contract method 0x34bfce4b.
//
// Solidity: function updateProjectOwner(uint256 projectId, address owner) returns()
func (_GasMonetization *GasMonetizationTransactorSession) UpdateProjectOwner(projectId *big.Int, owner common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateProjectOwner(&_GasMonetization.TransactOpts, projectId, owner)
}

// UpdateProjectRewardsRecipient is a paid mutator transaction binding the contract method 0x92cf316b.
//
// Solidity: function updateProjectRewardsRecipient(uint256 projectId, address recipient) returns()
func (_GasMonetization *GasMonetizationTransactor) UpdateProjectRewardsRecipient(opts *bind.TransactOpts, projectId *big.Int, recipient common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "updateProjectRewardsRecipient", projectId, recipient)
}

// UpdateProjectRewardsRecipient is a paid mutator transaction binding the contract method 0x92cf316b.
//
// Solidity: function updateProjectRewardsRecipient(uint256 projectId, address recipient) returns()
func (_GasMonetization *GasMonetizationSession) UpdateProjectRewardsRecipient(projectId *big.Int, recipient common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateProjectRewardsRecipient(&_GasMonetization.TransactOpts, projectId, recipient)
}

// UpdateProjectRewardsRecipient is a paid mutator transaction binding the contract method 0x92cf316b.
//
// Solidity: function updateProjectRewardsRecipient(uint256 projectId, address recipient) returns()
func (_GasMonetization *GasMonetizationTransactorSession) UpdateProjectRewardsRecipient(projectId *big.Int, recipient common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateProjectRewardsRecipient(&_GasMonetization.TransactOpts, projectId, recipient)
}

// UpdateSfcAddress is a paid mutator transaction binding the contract method 0xcbb9d8c9.
//
// Solidity: function updateSfcAddress(address sfc) returns()
func (_GasMonetization *GasMonetizationTransactor) UpdateSfcAddress(opts *bind.TransactOpts, sfc common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "updateSfcAddress", sfc)
}

// UpdateSfcAddress is a paid mutator transaction binding the contract method 0xcbb9d8c9.
//
// Solidity: function updateSfcAddress(address sfc) returns()
func (_GasMonetization *GasMonetizationSession) UpdateSfcAddress(sfc common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateSfcAddress(&_GasMonetization.TransactOpts, sfc)
}

// UpdateSfcAddress is a paid mutator transaction binding the contract method 0xcbb9d8c9.
//
// Solidity: function updateSfcAddress(address sfc) returns()
func (_GasMonetization *GasMonetizationTransactorSession) UpdateSfcAddress(sfc common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateSfcAddress(&_GasMonetization.TransactOpts, sfc)
}

// UpdateWithdrawalConfirmationsLimit is a paid mutator transaction binding the contract method 0xa210106f.
//
// Solidity: function updateWithdrawalConfirmationsLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationTransactor) UpdateWithdrawalConfirmationsLimit(opts *bind.TransactOpts, limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "updateWithdrawalConfirmationsLimit", limit)
}

// UpdateWithdrawalConfirmationsLimit is a paid mutator transaction binding the contract method 0xa210106f.
//
// Solidity: function updateWithdrawalConfirmationsLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationSession) UpdateWithdrawalConfirmationsLimit(limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateWithdrawalConfirmationsLimit(&_GasMonetization.TransactOpts, limit)
}

// UpdateWithdrawalConfirmationsLimit is a paid mutator transaction binding the contract method 0xa210106f.
//
// Solidity: function updateWithdrawalConfirmationsLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationTransactorSession) UpdateWithdrawalConfirmationsLimit(limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateWithdrawalConfirmationsLimit(&_GasMonetization.TransactOpts, limit)
}

// UpdateWithdrawalEpochsFrequencyLimit is a paid mutator transaction binding the contract method 0x5fac2ba8.
//
// Solidity: function updateWithdrawalEpochsFrequencyLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationTransactor) UpdateWithdrawalEpochsFrequencyLimit(opts *bind.TransactOpts, limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "updateWithdrawalEpochsFrequencyLimit", limit)
}

// UpdateWithdrawalEpochsFrequencyLimit is a paid mutator transaction binding the contract method 0x5fac2ba8.
//
// Solidity: function updateWithdrawalEpochsFrequencyLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationSession) UpdateWithdrawalEpochsFrequencyLimit(limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateWithdrawalEpochsFrequencyLimit(&_GasMonetization.TransactOpts, limit)
}

// UpdateWithdrawalEpochsFrequencyLimit is a paid mutator transaction binding the contract method 0x5fac2ba8.
//
// Solidity: function updateWithdrawalEpochsFrequencyLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationTransactorSession) UpdateWithdrawalEpochsFrequencyLimit(limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateWithdrawalEpochsFrequencyLimit(&_GasMonetization.TransactOpts, limit)
}

// WithdrawAllFunds is a paid mutator transaction binding the contract method 0x32dee40b.
//
// Solidity: function withdrawAllFunds(address recipient) returns()
func (_GasMonetization *GasMonetizationTransactor) WithdrawAllFunds(opts *bind.TransactOpts, recipient common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "withdrawAllFunds", recipient)
}

// WithdrawAllFunds is a paid mutator transaction binding the contract method 0x32dee40b.
//
// Solidity: function withdrawAllFunds(address recipient) returns()
func (_GasMonetization *GasMonetizationSession) WithdrawAllFunds(recipient common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.WithdrawAllFunds(&_GasMonetization.TransactOpts, recipient)
}

// WithdrawAllFunds is a paid mutator transaction binding the contract method 0x32dee40b.
//
// Solidity: function withdrawAllFunds(address recipient) returns()
func (_GasMonetization *GasMonetizationTransactorSession) WithdrawAllFunds(recipient common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.WithdrawAllFunds(&_GasMonetization.TransactOpts, recipient)
}

// WithdrawFunds is a paid mutator transaction binding the contract method 0xc1075329.
//
// Solidity: function withdrawFunds(address recipient, uint256 amount) returns()
func (_GasMonetization *GasMonetizationTransactor) WithdrawFunds(opts *bind.TransactOpts, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "withdrawFunds", recipient, amount)
}

// WithdrawFunds is a paid mutator transaction binding the contract method 0xc1075329.
//
// Solidity: function withdrawFunds(address recipient, uint256 amount) returns()
func (_GasMonetization *GasMonetizationSession) WithdrawFunds(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.WithdrawFunds(&_GasMonetization.TransactOpts, recipient, amount)
}

// WithdrawFunds is a paid mutator transaction binding the contract method 0xc1075329.
//
// Solidity: function withdrawFunds(address recipient, uint256 amount) returns()
func (_GasMonetization *GasMonetizationTransactorSession) WithdrawFunds(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.WithdrawFunds(&_GasMonetization.TransactOpts, recipient, amount)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_GasMonetization *GasMonetizationTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasMonetization.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_GasMonetization *GasMonetizationSession) Receive() (*types.Transaction, error) {
	return _GasMonetization.Contract.Receive(&_GasMonetization.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_GasMonetization *GasMonetizationTransactorSession) Receive() (*types.Transaction, error) {
	return _GasMonetization.Contract.Receive(&_GasMonetization.TransactOpts)
}

// GasMonetizationContractDeployedIterator is returned from FilterContractDeployed and is used to iterate over the raw logs and unpacked data for ContractDeployed events raised by the GasMonetization contract.
type GasMonetizationContractDeployedIterator struct {
	Event *GasMonetizationContractDeployed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationContractDeployedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationContractDeployed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationContractDeployed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationContractDeployedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationContractDeployedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationContractDeployed represents a ContractDeployed event raised by the GasMonetization contract.
type GasMonetizationContractDeployed struct {
	SfcAddress                     common.Address
	WithdrawalEpochsFrequencyLimit *big.Int
	ConfirmationsToMakeWithdrawal  *big.Int
	Raw                            types.Log // Blockchain specific contextual infos
}

// FilterContractDeployed is a free log retrieval operation binding the contract event 0x841dc6a6c60372f7a25ab4e5cb947a19940954c4364b1badbc999dc6f5704868.
//
// Solidity: event ContractDeployed(address sfcAddress, uint256 withdrawalEpochsFrequencyLimit, uint256 confirmationsToMakeWithdrawal)
func (_GasMonetization *GasMonetizationFilterer) FilterContractDeployed(opts *bind.FilterOpts) (*GasMonetizationContractDeployedIterator, error) {

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ContractDeployed")
	if err != nil {
		return nil, err
	}
	return &GasMonetizationContractDeployedIterator{contract: _GasMonetization.contract, event: "ContractDeployed", logs: logs, sub: sub}, nil
}

// WatchContractDeployed is a free log subscription operation binding the contract event 0x841dc6a6c60372f7a25ab4e5cb947a19940954c4364b1badbc999dc6f5704868.
//
// Solidity: event ContractDeployed(address sfcAddress, uint256 withdrawalEpochsFrequencyLimit, uint256 confirmationsToMakeWithdrawal)
func (_GasMonetization *GasMonetizationFilterer) WatchContractDeployed(opts *bind.WatchOpts, sink chan<- *GasMonetizationContractDeployed) (event.Subscription, error) {

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ContractDeployed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationContractDeployed)
				if err := _GasMonetization.contract.UnpackLog(event, "ContractDeployed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseContractDeployed is a log parse operation binding the contract event 0x841dc6a6c60372f7a25ab4e5cb947a19940954c4364b1badbc999dc6f5704868.
//
// Solidity: event ContractDeployed(address sfcAddress, uint256 withdrawalEpochsFrequencyLimit, uint256 confirmationsToMakeWithdrawal)
func (_GasMonetization *GasMonetizationFilterer) ParseContractDeployed(log types.Log) (*GasMonetizationContractDeployed, error) {
	event := new(GasMonetizationContractDeployed)
	if err := _GasMonetization.contract.UnpackLog(event, "ContractDeployed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationFundsAddedIterator is returned from FilterFundsAdded and is used to iterate over the raw logs and unpacked data for FundsAdded events raised by the GasMonetization contract.
type GasMonetizationFundsAddedIterator struct {
	Event *GasMonetizationFundsAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationFundsAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationFundsAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationFundsAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationFundsAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationFundsAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationFundsAdded represents a FundsAdded event raised by the GasMonetization contract.
type GasMonetizationFundsAdded struct {
	Funder common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterFundsAdded is a free log retrieval operation binding the contract event 0x8fe10ae416f22f5e5220b0018a6c1d4ff534d6aa3a471f2a20cb7747fe63e5b9.
//
// Solidity: event FundsAdded(address indexed funder, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) FilterFundsAdded(opts *bind.FilterOpts, funder []common.Address) (*GasMonetizationFundsAddedIterator, error) {

	var funderRule []interface{}
	for _, funderItem := range funder {
		funderRule = append(funderRule, funderItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "FundsAdded", funderRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationFundsAddedIterator{contract: _GasMonetization.contract, event: "FundsAdded", logs: logs, sub: sub}, nil
}

// WatchFundsAdded is a free log subscription operation binding the contract event 0x8fe10ae416f22f5e5220b0018a6c1d4ff534d6aa3a471f2a20cb7747fe63e5b9.
//
// Solidity: event FundsAdded(address indexed funder, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) WatchFundsAdded(opts *bind.WatchOpts, sink chan<- *GasMonetizationFundsAdded, funder []common.Address) (event.Subscription, error) {

	var funderRule []interface{}
	for _, funderItem := range funder {
		funderRule = append(funderRule, funderItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "FundsAdded", funderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationFundsAdded)
				if err := _GasMonetization.contract.UnpackLog(event, "FundsAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFundsAdded is a log parse operation binding the contract event 0x8fe10ae416f22f5e5220b0018a6c1d4ff534d6aa3a471f2a20cb7747fe63e5b9.
//
// Solidity: event FundsAdded(address indexed funder, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) ParseFundsAdded(log types.Log) (*GasMonetizationFundsAdded, error) {
	event := new(GasMonetizationFundsAdded)
	if err := _GasMonetization.contract.UnpackLog(event, "FundsAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationFundsWithdrawnIterator is returned from FilterFundsWithdrawn and is used to iterate over the raw logs and unpacked data for FundsWithdrawn events raised by the GasMonetization contract.
type GasMonetizationFundsWithdrawnIterator struct {
	Event *GasMonetizationFundsWithdrawn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationFundsWithdrawnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationFundsWithdrawn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationFundsWithdrawn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationFundsWithdrawnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationFundsWithdrawnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationFundsWithdrawn represents a FundsWithdrawn event raised by the GasMonetization contract.
type GasMonetizationFundsWithdrawn struct {
	Recipient common.Address
	Amount    *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterFundsWithdrawn is a free log retrieval operation binding the contract event 0xeaff4b37086828766ad3268786972c0cd24259d4c87a80f9d3963a3c3d999b0d.
//
// Solidity: event FundsWithdrawn(address indexed recipient, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) FilterFundsWithdrawn(opts *bind.FilterOpts, recipient []common.Address) (*GasMonetizationFundsWithdrawnIterator, error) {

	var recipientRule []interface{}
	for _, recipientItem := range recipient {
		recipientRule = append(recipientRule, recipientItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "FundsWithdrawn", recipientRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationFundsWithdrawnIterator{contract: _GasMonetization.contract, event: "FundsWithdrawn", logs: logs, sub: sub}, nil
}

// WatchFundsWithdrawn is a free log subscription operation binding the contract event 0xeaff4b37086828766ad3268786972c0cd24259d4c87a80f9d3963a3c3d999b0d.
//
// Solidity: event FundsWithdrawn(address indexed recipient, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) WatchFundsWithdrawn(opts *bind.WatchOpts, sink chan<- *GasMonetizationFundsWithdrawn, recipient []common.Address) (event.Subscription, error) {

	var recipientRule []interface{}
	for _, recipientItem := range recipient {
		recipientRule = append(recipientRule, recipientItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "FundsWithdrawn", recipientRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationFundsWithdrawn)
				if err := _GasMonetization.contract.UnpackLog(event, "FundsWithdrawn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFundsWithdrawn is a log parse operation binding the contract event 0xeaff4b37086828766ad3268786972c0cd24259d4c87a80f9d3963a3c3d999b0d.
//
// Solidity: event FundsWithdrawn(address indexed recipient, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) ParseFundsWithdrawn(log types.Log) (*GasMonetizationFundsWithdrawn, error) {
	event := new(GasMonetizationFundsWithdrawn)
	if err := _GasMonetization.contract.UnpackLog(event, "FundsWithdrawn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationInvalidWithdrawalAmountIterator is returned from FilterInvalidWithdrawalAmount and is used to iterate over the raw logs and unpacked data for InvalidWithdrawalAmount events raised by the GasMonetization contract.
type GasMonetizationInvalidWithdrawalAmountIterator struct {
	Event *GasMonetizationInvalidWithdrawalAmount // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationInvalidWithdrawalAmountIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationInvalidWithdrawalAmount)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationInvalidWithdrawalAmount)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationInvalidWithdrawalAmountIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationInvalidWithdrawalAmountIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationInvalidWithdrawalAmount represents a InvalidWithdrawalAmount event raised by the GasMonetization contract.
type GasMonetizationInvalidWithdrawalAmount struct {
	ProjectId             *big.Int
	WithdrawalEpochNumber *big.Int
	Amount                *big.Int
	DiffAmount            *big.Int
	Raw                   types.Log // Blockchain specific contextual infos
}

// FilterInvalidWithdrawalAmount is a free log retrieval operation binding the contract event 0xe13f2d157714b016f2b9ff3d2db5002bca0925cf357170d6ab0bd1867ce6880b.
//
// Solidity: event InvalidWithdrawalAmount(uint256 indexed projectId, uint256 withdrawalEpochNumber, uint256 amount, uint256 diffAmount)
func (_GasMonetization *GasMonetizationFilterer) FilterInvalidWithdrawalAmount(opts *bind.FilterOpts, projectId []*big.Int) (*GasMonetizationInvalidWithdrawalAmountIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "InvalidWithdrawalAmount", projectIdRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationInvalidWithdrawalAmountIterator{contract: _GasMonetization.contract, event: "InvalidWithdrawalAmount", logs: logs, sub: sub}, nil
}

// WatchInvalidWithdrawalAmount is a free log subscription operation binding the contract event 0xe13f2d157714b016f2b9ff3d2db5002bca0925cf357170d6ab0bd1867ce6880b.
//
// Solidity: event InvalidWithdrawalAmount(uint256 indexed projectId, uint256 withdrawalEpochNumber, uint256 amount, uint256 diffAmount)
func (_GasMonetization *GasMonetizationFilterer) WatchInvalidWithdrawalAmount(opts *bind.WatchOpts, sink chan<- *GasMonetizationInvalidWithdrawalAmount, projectId []*big.Int) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "InvalidWithdrawalAmount", projectIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationInvalidWithdrawalAmount)
				if err := _GasMonetization.contract.UnpackLog(event, "InvalidWithdrawalAmount", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidWithdrawalAmount is a log parse operation binding the contract event 0xe13f2d157714b016f2b9ff3d2db5002bca0925cf357170d6ab0bd1867ce6880b.
//
// Solidity: event InvalidWithdrawalAmount(uint256 indexed projectId, uint256 withdrawalEpochNumber, uint256 amount, uint256 diffAmount)
func (_GasMonetization *GasMonetizationFilterer) ParseInvalidWithdrawalAmount(log types.Log) (*GasMonetizationInvalidWithdrawalAmount, error) {
	event := new(GasMonetizationInvalidWithdrawalAmount)
	if err := _GasMonetization.contract.UnpackLog(event, "InvalidWithdrawalAmount", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectAddedIterator is returned from FilterProjectAdded and is used to iterate over the raw logs and unpacked data for ProjectAdded events raised by the GasMonetization contract.
type GasMonetizationProjectAddedIterator struct {
	Event *GasMonetizationProjectAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectAdded represents a ProjectAdded event raised by the GasMonetization contract.
type GasMonetizationProjectAdded struct {
	ProjectId        *big.Int
	Owner            common.Address
	RewardsRecipient common.Address
	MetadataUri      string
	ActiveFromEpoch  *big.Int
	Contracts        []common.Address
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterProjectAdded is a free log retrieval operation binding the contract event 0xa8f2a13a6c4c221e863c34b0174b2a8356551bc645dc295ae4b5796c240915aa.
//
// Solidity: event ProjectAdded(uint256 indexed projectId, address indexed owner, address indexed rewardsRecipient, string metadataUri, uint256 activeFromEpoch, address[] contracts)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectAdded(opts *bind.FilterOpts, projectId []*big.Int, owner []common.Address, rewardsRecipient []common.Address) (*GasMonetizationProjectAddedIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var rewardsRecipientRule []interface{}
	for _, rewardsRecipientItem := range rewardsRecipient {
		rewardsRecipientRule = append(rewardsRecipientRule, rewardsRecipientItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectAdded", projectIdRule, ownerRule, rewardsRecipientRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectAddedIterator{contract: _GasMonetization.contract, event: "ProjectAdded", logs: logs, sub: sub}, nil
}

// WatchProjectAdded is a free log subscription operation binding the contract event 0xa8f2a13a6c4c221e863c34b0174b2a8356551bc645dc295ae4b5796c240915aa.
//
// Solidity: event ProjectAdded(uint256 indexed projectId, address indexed owner, address indexed rewardsRecipient, string metadataUri, uint256 activeFromEpoch, address[] contracts)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectAdded(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectAdded, projectId []*big.Int, owner []common.Address, rewardsRecipient []common.Address) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var rewardsRecipientRule []interface{}
	for _, rewardsRecipientItem := range rewardsRecipient {
		rewardsRecipientRule = append(rewardsRecipientRule, rewardsRecipientItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectAdded", projectIdRule, ownerRule, rewardsRecipientRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectAdded)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectAdded is a log parse operation binding the contract event 0xa8f2a13a6c4c221e863c34b0174b2a8356551bc645dc295ae4b5796c240915aa.
//
// Solidity: event ProjectAdded(uint256 indexed projectId, address indexed owner, address indexed rewardsRecipient, string metadataUri, uint256 activeFromEpoch, address[] contracts)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectAdded(log types.Log) (*GasMonetizationProjectAdded, error) {
	event := new(GasMonetizationProjectAdded)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectContractAddedIterator is returned from FilterProjectContractAdded and is used to iterate over the raw logs and unpacked data for ProjectContractAdded events raised by the GasMonetization contract.
type GasMonetizationProjectContractAddedIterator struct {
	Event *GasMonetizationProjectContractAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectContractAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectContractAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectContractAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectContractAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectContractAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectContractAdded represents a ProjectContractAdded event raised by the GasMonetization contract.
type GasMonetizationProjectContractAdded struct {
	ProjectId       *big.Int
	ContractAddress common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterProjectContractAdded is a free log retrieval operation binding the contract event 0xf83ba82192ce64f0fd48145ca2b60956a005a2d4e28f14fb099fad71294b8ff3.
//
// Solidity: event ProjectContractAdded(uint256 indexed projectId, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectContractAdded(opts *bind.FilterOpts, projectId []*big.Int, contractAddress []common.Address) (*GasMonetizationProjectContractAddedIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectContractAdded", projectIdRule, contractAddressRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectContractAddedIterator{contract: _GasMonetization.contract, event: "ProjectContractAdded", logs: logs, sub: sub}, nil
}

// WatchProjectContractAdded is a free log subscription operation binding the contract event 0xf83ba82192ce64f0fd48145ca2b60956a005a2d4e28f14fb099fad71294b8ff3.
//
// Solidity: event ProjectContractAdded(uint256 indexed projectId, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectContractAdded(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectContractAdded, projectId []*big.Int, contractAddress []common.Address) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectContractAdded", projectIdRule, contractAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectContractAdded)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectContractAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectContractAdded is a log parse operation binding the contract event 0xf83ba82192ce64f0fd48145ca2b60956a005a2d4e28f14fb099fad71294b8ff3.
//
// Solidity: event ProjectContractAdded(uint256 indexed projectId, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectContractAdded(log types.Log) (*GasMonetizationProjectContractAdded, error) {
	event := new(GasMonetizationProjectContractAdded)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectContractAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectContractRemovedIterator is returned from FilterProjectContractRemoved and is used to iterate over the raw logs and unpacked data for ProjectContractRemoved events raised by the GasMonetization contract.
type GasMonetizationProjectContractRemovedIterator struct {
	Event *GasMonetizationProjectContractRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectContractRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectContractRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectContractRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectContractRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectContractRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectContractRemoved represents a ProjectContractRemoved event raised by the GasMonetization contract.
type GasMonetizationProjectContractRemoved struct {
	ProjectId       *big.Int
	ContractAddress common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterProjectContractRemoved is a free log retrieval operation binding the contract event 0xd32f2e923c29ff9e7231f459d69add67f769d05c5069c23bbdea536fc0cf154a.
//
// Solidity: event ProjectContractRemoved(uint256 indexed projectId, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectContractRemoved(opts *bind.FilterOpts, projectId []*big.Int, contractAddress []common.Address) (*GasMonetizationProjectContractRemovedIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectContractRemoved", projectIdRule, contractAddressRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectContractRemovedIterator{contract: _GasMonetization.contract, event: "ProjectContractRemoved", logs: logs, sub: sub}, nil
}

// WatchProjectContractRemoved is a free log subscription operation binding the contract event 0xd32f2e923c29ff9e7231f459d69add67f769d05c5069c23bbdea536fc0cf154a.
//
// Solidity: event ProjectContractRemoved(uint256 indexed projectId, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectContractRemoved(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectContractRemoved, projectId []*big.Int, contractAddress []common.Address) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectContractRemoved", projectIdRule, contractAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectContractRemoved)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectContractRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectContractRemoved is a log parse operation binding the contract event 0xd32f2e923c29ff9e7231f459d69add67f769d05c5069c23bbdea536fc0cf154a.
//
// Solidity: event ProjectContractRemoved(uint256 indexed projectId, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectContractRemoved(log types.Log) (*GasMonetizationProjectContractRemoved, error) {
	event := new(GasMonetizationProjectContractRemoved)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectContractRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectEnabledIterator is returned from FilterProjectEnabled and is used to iterate over the raw logs and unpacked data for ProjectEnabled events raised by the GasMonetization contract.
type GasMonetizationProjectEnabledIterator struct {
	Event *GasMonetizationProjectEnabled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectEnabledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectEnabled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectEnabled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectEnabledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectEnabledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectEnabled represents a ProjectEnabled event raised by the GasMonetization contract.
type GasMonetizationProjectEnabled struct {
	ProjectId            *big.Int
	EnabledOnEpochNumber *big.Int
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterProjectEnabled is a free log retrieval operation binding the contract event 0x0737ed2cc6eb4cf4aefb6d1e1404305301a64cae58ccf508828a20412fb77f35.
//
// Solidity: event ProjectEnabled(uint256 indexed projectId, uint256 enabledOnEpochNumber)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectEnabled(opts *bind.FilterOpts, projectId []*big.Int) (*GasMonetizationProjectEnabledIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectEnabled", projectIdRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectEnabledIterator{contract: _GasMonetization.contract, event: "ProjectEnabled", logs: logs, sub: sub}, nil
}

// WatchProjectEnabled is a free log subscription operation binding the contract event 0x0737ed2cc6eb4cf4aefb6d1e1404305301a64cae58ccf508828a20412fb77f35.
//
// Solidity: event ProjectEnabled(uint256 indexed projectId, uint256 enabledOnEpochNumber)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectEnabled(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectEnabled, projectId []*big.Int) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectEnabled", projectIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectEnabled)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectEnabled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectEnabled is a log parse operation binding the contract event 0x0737ed2cc6eb4cf4aefb6d1e1404305301a64cae58ccf508828a20412fb77f35.
//
// Solidity: event ProjectEnabled(uint256 indexed projectId, uint256 enabledOnEpochNumber)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectEnabled(log types.Log) (*GasMonetizationProjectEnabled, error) {
	event := new(GasMonetizationProjectEnabled)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectEnabled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectMetadataUriUpdatedIterator is returned from FilterProjectMetadataUriUpdated and is used to iterate over the raw logs and unpacked data for ProjectMetadataUriUpdated events raised by the GasMonetization contract.
type GasMonetizationProjectMetadataUriUpdatedIterator struct {
	Event *GasMonetizationProjectMetadataUriUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectMetadataUriUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectMetadataUriUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectMetadataUriUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectMetadataUriUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectMetadataUriUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectMetadataUriUpdated represents a ProjectMetadataUriUpdated event raised by the GasMonetization contract.
type GasMonetizationProjectMetadataUriUpdated struct {
	ProjectId   *big.Int
	MetadataUri string
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterProjectMetadataUriUpdated is a free log retrieval operation binding the contract event 0x781779743e625d6e652139cabc7e7c736ad376a0f1302b1b5c346548d948c72e.
//
// Solidity: event ProjectMetadataUriUpdated(uint256 indexed projectId, string metadataUri)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectMetadataUriUpdated(opts *bind.FilterOpts, projectId []*big.Int) (*GasMonetizationProjectMetadataUriUpdatedIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectMetadataUriUpdated", projectIdRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectMetadataUriUpdatedIterator{contract: _GasMonetization.contract, event: "ProjectMetadataUriUpdated", logs: logs, sub: sub}, nil
}

// WatchProjectMetadataUriUpdated is a free log subscription operation binding the contract event 0x781779743e625d6e652139cabc7e7c736ad376a0f1302b1b5c346548d948c72e.
//
// Solidity: event ProjectMetadataUriUpdated(uint256 indexed projectId, string metadataUri)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectMetadataUriUpdated(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectMetadataUriUpdated, projectId []*big.Int) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectMetadataUriUpdated", projectIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectMetadataUriUpdated)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectMetadataUriUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectMetadataUriUpdated is a log parse operation binding the contract event 0x781779743e625d6e652139cabc7e7c736ad376a0f1302b1b5c346548d948c72e.
//
// Solidity: event ProjectMetadataUriUpdated(uint256 indexed projectId, string metadataUri)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectMetadataUriUpdated(log types.Log) (*GasMonetizationProjectMetadataUriUpdated, error) {
	event := new(GasMonetizationProjectMetadataUriUpdated)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectMetadataUriUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectOwnerUpdatedIterator is returned from FilterProjectOwnerUpdated and is used to iterate over the raw logs and unpacked data for ProjectOwnerUpdated events raised by the GasMonetization contract.
type GasMonetizationProjectOwnerUpdatedIterator struct {
	Event *GasMonetizationProjectOwnerUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectOwnerUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectOwnerUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectOwnerUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectOwnerUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectOwnerUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectOwnerUpdated represents a ProjectOwnerUpdated event raised by the GasMonetization contract.
type GasMonetizationProjectOwnerUpdated struct {
	ProjectId *big.Int
	Owner     common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterProjectOwnerUpdated is a free log retrieval operation binding the contract event 0xffc579e983741c17a95792c458e2ae8c933b1bf7f5cd84f3bca571505c25d42a.
//
// Solidity: event ProjectOwnerUpdated(uint256 indexed projectId, address owner)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectOwnerUpdated(opts *bind.FilterOpts, projectId []*big.Int) (*GasMonetizationProjectOwnerUpdatedIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectOwnerUpdated", projectIdRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectOwnerUpdatedIterator{contract: _GasMonetization.contract, event: "ProjectOwnerUpdated", logs: logs, sub: sub}, nil
}

// WatchProjectOwnerUpdated is a free log subscription operation binding the contract event 0xffc579e983741c17a95792c458e2ae8c933b1bf7f5cd84f3bca571505c25d42a.
//
// Solidity: event ProjectOwnerUpdated(uint256 indexed projectId, address owner)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectOwnerUpdated(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectOwnerUpdated, projectId []*big.Int) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectOwnerUpdated", projectIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectOwnerUpdated)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectOwnerUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectOwnerUpdated is a log parse operation binding the contract event 0xffc579e983741c17a95792c458e2ae8c933b1bf7f5cd84f3bca571505c25d42a.
//
// Solidity: event ProjectOwnerUpdated(uint256 indexed projectId, address owner)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectOwnerUpdated(log types.Log) (*GasMonetizationProjectOwnerUpdated, error) {
	event := new(GasMonetizationProjectOwnerUpdated)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectOwnerUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectRewardsRecipientUpdatedIterator is returned from FilterProjectRewardsRecipientUpdated and is used to iterate over the raw logs and unpacked data for ProjectRewardsRecipientUpdated events raised by the GasMonetization contract.
type GasMonetizationProjectRewardsRecipientUpdatedIterator struct {
	Event *GasMonetizationProjectRewardsRecipientUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectRewardsRecipientUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectRewardsRecipientUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectRewardsRecipientUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectRewardsRecipientUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectRewardsRecipientUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectRewardsRecipientUpdated represents a ProjectRewardsRecipientUpdated event raised by the GasMonetization contract.
type GasMonetizationProjectRewardsRecipientUpdated struct {
	ProjectId *big.Int
	Recipient common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterProjectRewardsRecipientUpdated is a free log retrieval operation binding the contract event 0xc96c5102d284d786d29b5d0d7dda6ce493724355b762993adfef62b7220f161c.
//
// Solidity: event ProjectRewardsRecipientUpdated(uint256 indexed projectId, address recipient)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectRewardsRecipientUpdated(opts *bind.FilterOpts, projectId []*big.Int) (*GasMonetizationProjectRewardsRecipientUpdatedIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectRewardsRecipientUpdated", projectIdRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectRewardsRecipientUpdatedIterator{contract: _GasMonetization.contract, event: "ProjectRewardsRecipientUpdated", logs: logs, sub: sub}, nil
}

// WatchProjectRewardsRecipientUpdated is a free log subscription operation binding the contract event 0xc96c5102d284d786d29b5d0d7dda6ce493724355b762993adfef62b7220f161c.
//
// Solidity: event ProjectRewardsRecipientUpdated(uint256 indexed projectId, address recipient)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectRewardsRecipientUpdated(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectRewardsRecipientUpdated, projectId []*big.Int) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectRewardsRecipientUpdated", projectIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectRewardsRecipientUpdated)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectRewardsRecipientUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectRewardsRecipientUpdated is a log parse operation binding the contract event 0xc96c5102d284d786d29b5d0d7dda6ce493724355b762993adfef62b7220f161c.
//
// Solidity: event ProjectRewardsRecipientUpdated(uint256 indexed projectId, address recipient)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectRewardsRecipientUpdated(log types.Log) (*GasMonetizationProjectRewardsRecipientUpdated, error) {
	event := new(GasMonetizationProjectRewardsRecipientUpdated)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectRewardsRecipientUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectSuspendedIterator is returned from FilterProjectSuspended and is used to iterate over the raw logs and unpacked data for ProjectSuspended events raised by the GasMonetization contract.
type GasMonetizationProjectSuspendedIterator struct {
	Event *GasMonetizationProjectSuspended // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectSuspendedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectSuspended)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectSuspended)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectSuspendedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectSuspendedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectSuspended represents a ProjectSuspended event raised by the GasMonetization contract.
type GasMonetizationProjectSuspended struct {
	ProjectId              *big.Int
	SuspendedOnEpochNumber *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterProjectSuspended is a free log retrieval operation binding the contract event 0x0c3ad6c6f2fc1e970caed51e87ac06c3a37569f33664f42771264a4ae8907822.
//
// Solidity: event ProjectSuspended(uint256 indexed projectId, uint256 suspendedOnEpochNumber)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectSuspended(opts *bind.FilterOpts, projectId []*big.Int) (*GasMonetizationProjectSuspendedIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectSuspended", projectIdRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectSuspendedIterator{contract: _GasMonetization.contract, event: "ProjectSuspended", logs: logs, sub: sub}, nil
}

// WatchProjectSuspended is a free log subscription operation binding the contract event 0x0c3ad6c6f2fc1e970caed51e87ac06c3a37569f33664f42771264a4ae8907822.
//
// Solidity: event ProjectSuspended(uint256 indexed projectId, uint256 suspendedOnEpochNumber)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectSuspended(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectSuspended, projectId []*big.Int) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectSuspended", projectIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectSuspended)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectSuspended", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectSuspended is a log parse operation binding the contract event 0x0c3ad6c6f2fc1e970caed51e87ac06c3a37569f33664f42771264a4ae8907822.
//
// Solidity: event ProjectSuspended(uint256 indexed projectId, uint256 suspendedOnEpochNumber)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectSuspended(log types.Log) (*GasMonetizationProjectSuspended, error) {
	event := new(GasMonetizationProjectSuspended)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectSuspended", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the GasMonetization contract.
type GasMonetizationRoleAdminChangedIterator struct {
	Event *GasMonetizationRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationRoleAdminChanged represents a RoleAdminChanged event raised by the GasMonetization contract.
type GasMonetizationRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_GasMonetization *GasMonetizationFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*GasMonetizationRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationRoleAdminChangedIterator{contract: _GasMonetization.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_GasMonetization *GasMonetizationFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *GasMonetizationRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationRoleAdminChanged)
				if err := _GasMonetization.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_GasMonetization *GasMonetizationFilterer) ParseRoleAdminChanged(log types.Log) (*GasMonetizationRoleAdminChanged, error) {
	event := new(GasMonetizationRoleAdminChanged)
	if err := _GasMonetization.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the GasMonetization contract.
type GasMonetizationRoleGrantedIterator struct {
	Event *GasMonetizationRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationRoleGranted represents a RoleGranted event raised by the GasMonetization contract.
type GasMonetizationRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*GasMonetizationRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationRoleGrantedIterator{contract: _GasMonetization.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *GasMonetizationRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationRoleGranted)
				if err := _GasMonetization.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) ParseRoleGranted(log types.Log) (*GasMonetizationRoleGranted, error) {
	event := new(GasMonetizationRoleGranted)
	if err := _GasMonetization.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the GasMonetization contract.
type GasMonetizationRoleRevokedIterator struct {
	Event *GasMonetizationRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationRoleRevoked represents a RoleRevoked event raised by the GasMonetization contract.
type GasMonetizationRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*GasMonetizationRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationRoleRevokedIterator{contract: _GasMonetization.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *GasMonetizationRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationRoleRevoked)
				if err := _GasMonetization.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) ParseRoleRevoked(log types.Log) (*GasMonetizationRoleRevoked, error) {
	event := new(GasMonetizationRoleRevoked)
	if err := _GasMonetization.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationSfcAddressUpdatedIterator is returned from FilterSfcAddressUpdated and is used to iterate over the raw logs and unpacked data for SfcAddressUpdated events raised by the GasMonetization contract.
type GasMonetizationSfcAddressUpdatedIterator struct {
	Event *GasMonetizationSfcAddressUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationSfcAddressUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationSfcAddressUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationSfcAddressUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationSfcAddressUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationSfcAddressUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationSfcAddressUpdated represents a SfcAddressUpdated event raised by the GasMonetization contract.
type GasMonetizationSfcAddressUpdated struct {
	SfcAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterSfcAddressUpdated is a free log retrieval operation binding the contract event 0x620e7fb0cccb30fce2c95f32e301054c7ba7fd3520a8f42891915c9d10efe95f.
//
// Solidity: event SfcAddressUpdated(address sfcAddress)
func (_GasMonetization *GasMonetizationFilterer) FilterSfcAddressUpdated(opts *bind.FilterOpts) (*GasMonetizationSfcAddressUpdatedIterator, error) {

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "SfcAddressUpdated")
	if err != nil {
		return nil, err
	}
	return &GasMonetizationSfcAddressUpdatedIterator{contract: _GasMonetization.contract, event: "SfcAddressUpdated", logs: logs, sub: sub}, nil
}

// WatchSfcAddressUpdated is a free log subscription operation binding the contract event 0x620e7fb0cccb30fce2c95f32e301054c7ba7fd3520a8f42891915c9d10efe95f.
//
// Solidity: event SfcAddressUpdated(address sfcAddress)
func (_GasMonetization *GasMonetizationFilterer) WatchSfcAddressUpdated(opts *bind.WatchOpts, sink chan<- *GasMonetizationSfcAddressUpdated) (event.Subscription, error) {

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "SfcAddressUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationSfcAddressUpdated)
				if err := _GasMonetization.contract.UnpackLog(event, "SfcAddressUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSfcAddressUpdated is a log parse operation binding the contract event 0x620e7fb0cccb30fce2c95f32e301054c7ba7fd3520a8f42891915c9d10efe95f.
//
// Solidity: event SfcAddressUpdated(address sfcAddress)
func (_GasMonetization *GasMonetizationFilterer) ParseSfcAddressUpdated(log types.Log) (*GasMonetizationSfcAddressUpdated, error) {
	event := new(GasMonetizationSfcAddressUpdated)
	if err := _GasMonetization.contract.UnpackLog(event, "SfcAddressUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationWithdrawalCompletedIterator is returned from FilterWithdrawalCompleted and is used to iterate over the raw logs and unpacked data for WithdrawalCompleted events raised by the GasMonetization contract.
type GasMonetizationWithdrawalCompletedIterator struct {
	Event *GasMonetizationWithdrawalCompleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationWithdrawalCompletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationWithdrawalCompleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationWithdrawalCompleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationWithdrawalCompletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationWithdrawalCompletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationWithdrawalCompleted represents a WithdrawalCompleted event raised by the GasMonetization contract.
type GasMonetizationWithdrawalCompleted struct {
	ProjectId             *big.Int
	RequestEpochNumber    *big.Int
	WithdrawalEpochNumber *big.Int
	Amount                *big.Int
	Raw                   types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalCompleted is a free log retrieval operation binding the contract event 0x709b466596e79834da0e8ee56d4624cb3e8464a18cd5ae894790b672594c402c.
//
// Solidity: event WithdrawalCompleted(uint256 indexed projectId, uint256 requestEpochNumber, uint256 withdrawalEpochNumber, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) FilterWithdrawalCompleted(opts *bind.FilterOpts, projectId []*big.Int) (*GasMonetizationWithdrawalCompletedIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "WithdrawalCompleted", projectIdRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationWithdrawalCompletedIterator{contract: _GasMonetization.contract, event: "WithdrawalCompleted", logs: logs, sub: sub}, nil
}

// WatchWithdrawalCompleted is a free log subscription operation binding the contract event 0x709b466596e79834da0e8ee56d4624cb3e8464a18cd5ae894790b672594c402c.
//
// Solidity: event WithdrawalCompleted(uint256 indexed projectId, uint256 requestEpochNumber, uint256 withdrawalEpochNumber, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) WatchWithdrawalCompleted(opts *bind.WatchOpts, sink chan<- *GasMonetizationWithdrawalCompleted, projectId []*big.Int) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "WithdrawalCompleted", projectIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationWithdrawalCompleted)
				if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalCompleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalCompleted is a log parse operation binding the contract event 0x709b466596e79834da0e8ee56d4624cb3e8464a18cd5ae894790b672594c402c.
//
// Solidity: event WithdrawalCompleted(uint256 indexed projectId, uint256 requestEpochNumber, uint256 withdrawalEpochNumber, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) ParseWithdrawalCompleted(log types.Log) (*GasMonetizationWithdrawalCompleted, error) {
	event := new(GasMonetizationWithdrawalCompleted)
	if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalCompleted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator is returned from FilterWithdrawalConfirmationsLimitUpdated and is used to iterate over the raw logs and unpacked data for WithdrawalConfirmationsLimitUpdated events raised by the GasMonetization contract.
type GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator struct {
	Event *GasMonetizationWithdrawalConfirmationsLimitUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationWithdrawalConfirmationsLimitUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationWithdrawalConfirmationsLimitUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationWithdrawalConfirmationsLimitUpdated represents a WithdrawalConfirmationsLimitUpdated event raised by the GasMonetization contract.
type GasMonetizationWithdrawalConfirmationsLimitUpdated struct {
	Limit *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalConfirmationsLimitUpdated is a free log retrieval operation binding the contract event 0x00209f2b72d564f415b7b96764fdee7ecf5f45854745e582a224b9a1a1ba1ddc.
//
// Solidity: event WithdrawalConfirmationsLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) FilterWithdrawalConfirmationsLimitUpdated(opts *bind.FilterOpts) (*GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator, error) {

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "WithdrawalConfirmationsLimitUpdated")
	if err != nil {
		return nil, err
	}
	return &GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator{contract: _GasMonetization.contract, event: "WithdrawalConfirmationsLimitUpdated", logs: logs, sub: sub}, nil
}

// WatchWithdrawalConfirmationsLimitUpdated is a free log subscription operation binding the contract event 0x00209f2b72d564f415b7b96764fdee7ecf5f45854745e582a224b9a1a1ba1ddc.
//
// Solidity: event WithdrawalConfirmationsLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) WatchWithdrawalConfirmationsLimitUpdated(opts *bind.WatchOpts, sink chan<- *GasMonetizationWithdrawalConfirmationsLimitUpdated) (event.Subscription, error) {

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "WithdrawalConfirmationsLimitUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationWithdrawalConfirmationsLimitUpdated)
				if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalConfirmationsLimitUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalConfirmationsLimitUpdated is a log parse operation binding the contract event 0x00209f2b72d564f415b7b96764fdee7ecf5f45854745e582a224b9a1a1ba1ddc.
//
// Solidity: event WithdrawalConfirmationsLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) ParseWithdrawalConfirmationsLimitUpdated(log types.Log) (*GasMonetizationWithdrawalConfirmationsLimitUpdated, error) {
	event := new(GasMonetizationWithdrawalConfirmationsLimitUpdated)
	if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalConfirmationsLimitUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationWithdrawalEpochsLimitUpdatedIterator is returned from FilterWithdrawalEpochsLimitUpdated and is used to iterate over the raw logs and unpacked data for WithdrawalEpochsLimitUpdated events raised by the GasMonetization contract.
type GasMonetizationWithdrawalEpochsLimitUpdatedIterator struct {
	Event *GasMonetizationWithdrawalEpochsLimitUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationWithdrawalEpochsLimitUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationWithdrawalEpochsLimitUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationWithdrawalEpochsLimitUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationWithdrawalEpochsLimitUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationWithdrawalEpochsLimitUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationWithdrawalEpochsLimitUpdated represents a WithdrawalEpochsLimitUpdated event raised by the GasMonetization contract.
type GasMonetizationWithdrawalEpochsLimitUpdated struct {
	Limit *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalEpochsLimitUpdated is a free log retrieval operation binding the contract event 0xcb570b7d503f0243c8b8d03ebe2eb0c7cbd366a3a96a1560a936d8b373019ff4.
//
// Solidity: event WithdrawalEpochsLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) FilterWithdrawalEpochsLimitUpdated(opts *bind.FilterOpts) (*GasMonetizationWithdrawalEpochsLimitUpdatedIterator, error) {

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "WithdrawalEpochsLimitUpdated")
	if err != nil {
		return nil, err
	}
	return &GasMonetizationWithdrawalEpochsLimitUpdatedIterator{contract: _GasMonetization.contract, event: "WithdrawalEpochsLimitUpdated", logs: logs, sub: sub}, nil
}

// WatchWithdrawalEpochsLimitUpdated is a free log subscription operation binding the contract event 0xcb570b7d503f0243c8b8d03ebe2eb0c7cbd366a3a96a1560a936d8b373019ff4.
//
// Solidity: event WithdrawalEpochsLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) WatchWithdrawalEpochsLimitUpdated(opts *bind.WatchOpts, sink chan<- *GasMonetizationWithdrawalEpochsLimitUpdated) (event.Subscription, error) {

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "WithdrawalEpochsLimitUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationWithdrawalEpochsLimitUpdated)
				if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalEpochsLimitUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalEpochsLimitUpdated is a log parse operation binding the contract event 0xcb570b7d503f0243c8b8d03ebe2eb0c7cbd366a3a96a1560a936d8b373019ff4.
//
// Solidity: event WithdrawalEpochsLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) ParseWithdrawalEpochsLimitUpdated(log types.Log) (*GasMonetizationWithdrawalEpochsLimitUpdated, error) {
	event := new(GasMonetizationWithdrawalEpochsLimitUpdated)
	if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalEpochsLimitUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationWithdrawalRequestedIterator is returned from FilterWithdrawalRequested and is used to iterate over the raw logs and unpacked data for WithdrawalRequested events raised by the GasMonetization contract.
type GasMonetizationWithdrawalRequestedIterator struct {
	Event *GasMonetizationWithdrawalRequested // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationWithdrawalRequestedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationWithdrawalRequested)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationWithdrawalRequested)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationWithdrawalRequestedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationWithdrawalRequestedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationWithdrawalRequested represents a WithdrawalRequested event raised by the GasMonetization contract.
type GasMonetizationWithdrawalRequested struct {
	ProjectId          *big.Int
	RequestEpochNumber *big.Int
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalRequested is a free log retrieval operation binding the contract event 0x6b19bb08027e5bee64cbe3f99bbbfb671c0e134643993f0ad046fd01d020b342.
//
// Solidity: event WithdrawalRequested(uint256 indexed projectId, uint256 requestEpochNumber)
func (_GasMonetization *GasMonetizationFilterer) FilterWithdrawalRequested(opts *bind.FilterOpts, projectId []*big.Int) (*GasMonetizationWithdrawalRequestedIterator, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "WithdrawalRequested", projectIdRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationWithdrawalRequestedIterator{contract: _GasMonetization.contract, event: "WithdrawalRequested", logs: logs, sub: sub}, nil
}

// WatchWithdrawalRequested is a free log subscription operation binding the contract event 0x6b19bb08027e5bee64cbe3f99bbbfb671c0e134643993f0ad046fd01d020b342.
//
// Solidity: event WithdrawalRequested(uint256 indexed projectId, uint256 requestEpochNumber)
func (_GasMonetization *GasMonetizationFilterer) WatchWithdrawalRequested(opts *bind.WatchOpts, sink chan<- *GasMonetizationWithdrawalRequested, projectId []*big.Int) (event.Subscription, error) {

	var projectIdRule []interface{}
	for _, projectIdItem := range projectId {
		projectIdRule = append(projectIdRule, projectIdItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "WithdrawalRequested", projectIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationWithdrawalRequested)
				if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalRequested", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalRequested is a log parse operation binding the contract event 0x6b19bb08027e5bee64cbe3f99bbbfb671c0e134643993f0ad046fd01d020b342.
//
// Solidity: event WithdrawalRequested(uint256 indexed projectId, uint256 requestEpochNumber)
func (_GasMonetization *GasMonetizationFilterer) ParseWithdrawalRequested(log types.Log) (*GasMonetizationWithdrawalRequested, error) {
	event := new(GasMonetizationWithdrawalRequested)
	if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalRequested", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
