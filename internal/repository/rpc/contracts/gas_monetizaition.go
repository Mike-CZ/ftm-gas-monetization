// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// GasMonetizationMetaData contains all meta data concerning the GasMonetization contract.
var GasMonetizationMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawalBlocksFrequencyLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"confirmationsToMakeWithdrawal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowedConfirmationsDeviation\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalBlocksFrequencyLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"confirmationsToMakeWithdrawal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allowedConfirmationsDeviation\",\"type\":\"uint256\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"ProjectAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ProjectContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ProjectContractRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"ProjectContractsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"}],\"name\":\"ProjectMetadataUriUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ProjectRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"WithdrawalBlockLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"WithdrawalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"WithdrawalConfirmationsDeviationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"WithdrawalConfirmationsLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"WithdrawalRequested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUNDER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUNDS_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROJECTS_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_DATA_PROVIDER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"addProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"addProjectContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"completeWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockId\",\"type\":\"uint256\"}],\"name\":\"hasPendingWithdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"removeProjectContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"setProjectContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"}],\"name\":\"updateProjectMetadataUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawalAllowedConfirmationsDeviation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawalBlocksFrequencyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawalConfirmationsLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawAllFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x608060405260006003553480156200001657600080fd5b5060405162002bbe38038062002bbe833981016040819052620000399162000140565b600483905560058290556006819055620000556000336200009f565b60408051848152602081018490529081018290527f9d6e529b64d0156dc8d51fd7a5e9e2c55ce73d15e239849a3a796f7e1c33ec819060600160405180910390a15050506200016f565b6000828152602081815260408083206001600160a01b038516845290915290205460ff166200013c576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620000fb3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45b5050565b6000806000606084860312156200015657600080fd5b8351925060208401519150604084015190509250925092565b612a3f806200017f6000396000f3fe6080604052600436106101855760003560e01c80639bfbca44116100d1578063c11173fe1161008a578063d788561511610064578063d7885615146104a7578063dbaf2145146104e1578063e9ba64a7146104f6578063fc07244f1461051657600080fd5b8063c11173fe14610433578063c4707a8314610453578063d547741f1461048757600080fd5b80639bfbca4414610382578063a210106f146103b6578063a217fddf146103d6578063a26759cb146103eb578063a6db775b146103f3578063c10753291461041357600080fd5b80633449b5b41161013e5780633c18315e116101185780633c18315e14610300578063571e86971461032057806379612e3a1461034257806391d148541461036257600080fd5b80633449b5b41461028c57806334aedecd146102ac57806336568abe146102e057600080fd5b806301ffc9a7146101995780630c0ad299146101ce578063191ba54e146101ee578063248a9ca31461020e5780632f2ff15d1461024c57806332dee40b1461026c57600080fd5b3661019457610192610536565b005b600080fd5b3480156101a557600080fd5b506101b96101b43660046120c5565b61063c565b60405190151581526020015b60405180910390f35b3480156101da57600080fd5b506101926101e9366004612104565b610673565b3480156101fa57600080fd5b5061019261020936600461216a565b6107f8565b34801561021a57600080fd5b5061023e6102293660046121bf565b60009081526020819052604090206001015490565b6040519081526020016101c5565b34801561025857600080fd5b506101926102673660046121d8565b6108f7565b34801561027857600080fd5b50610192610287366004612104565b610921565b34801561029857600080fd5b506101926102a7366004612208565b6109c2565b3480156102b857600080fd5b5061023e7f4f506ac322e467a10b006ee5ecfc5b7781c5c43d2ffbc468de868900d27b994581565b3480156102ec57600080fd5b506101926102fb3660046121d8565b610c7d565b34801561030c57600080fd5b5061019261031b3660046121bf565b610cfb565b34801561032c57600080fd5b5061023e6000805160206129ea83398151915281565b34801561034e57600080fd5b5061019261035d366004612208565b610d5e565b34801561036e57600080fd5b506101b961037d3660046121d8565b610e90565b34801561038e57600080fd5b5061023e7fb7afb381c2ec32313122d8bf9a9482db2de1a2e999efd75492ca6194dae14f3d81565b3480156103c257600080fd5b506101926103d13660046121bf565b610eb9565b3480156103e257600080fd5b5061023e600081565b610192610536565b3480156103ff57600080fd5b5061019261040e36600461227b565b610f14565b34801561041f57600080fd5b5061019261042e3660046122c3565b61117a565b34801561043f57600080fd5b5061019261044e3660046121bf565b6111d3565b34801561045f57600080fd5b5061023e7f93779bf6be703205517715c86297c193472c9d5533e90609b671022041168a4c81565b34801561049357600080fd5b506101926104a23660046121d8565b61122f565b3480156104b357600080fd5b506101b96104c23660046122c3565b6001600160a01b03919091166000908152600760205260409020541490565b3480156104ed57600080fd5b50610192611254565b34801561050257600080fd5b506101926105113660046122ef565b611409565b34801561052257600080fd5b50610192610531366004612372565b6116d4565b6105607f4f506ac322e467a10b006ee5ecfc5b7781c5c43d2ffbc468de868900d27b994533610e90565b6105b15760405162461bcd60e51b815260206004820152601b60248201527f4761734d6f6e6574697a6174696f6e3a206e6f742066756e646572000000000060448201526064015b60405180910390fd5b600034116106015760405162461bcd60e51b815260206004820152601e60248201527f4761734d6f6e6574697a6174696f6e3a206e6f2066756e64732073656e74000060448201526064016105a8565b4360035560405134815233907f8fe10ae416f22f5e5220b0018a6c1d4ff534d6aa3a471f2a20cb7747fe63e5b99060200160405180910390a2565b60006001600160e01b03198216637965db0b60e01b148061066d57506301ffc9a760e01b6001600160e01b03198316145b92915050565b61068b6000805160206129ea83398151915233610e90565b6106a75760405162461bcd60e51b81526004016105a8906123a7565b6001600160a01b038116600090815260016020526040812080546106ca906123ec565b9050116106e95760405162461bcd60e51b81526004016105a890612426565b60005b6001600160a01b038216600090815260016020526040902060020154811015610783576001600160a01b038216600090815260016020526040812060029081018054919291849081106107415761074161246d565b60009182526020808320909101546001600160a01b03168352820192909252604001902080546001600160a01b031916905561077c81612499565b90506106ec565b506001600160a01b0381166000908152600160205260408120906107a78282611fa0565b60018201600090556002820160006107bf9190611fda565b50506040516001600160a01b038216907f6c2a7bedc1e997c07f41aff265f8b77df645943615e2b039fb2b1f2be37b67da90600090a250565b6108106000805160206129ea83398151915233610e90565b61082c5760405162461bcd60e51b81526004016105a8906123a7565b6001600160a01b0383166000908152600160205260408120805461084f906123ec565b90501161086e5760405162461bcd60e51b81526004016105a890612426565b8061088b5760405162461bcd60e51b81526004016105a8906124b2565b6001600160a01b03831660009081526001602052604090206108ae828483612559565b50826001600160a01b03167f314a36dc8be566f41b94f41a0a6e3246b42dd5d4169ed073ebea2e3973a13a9983836040516108ea92919061261a565b60405180910390a2505050565b60008281526020819052604090206001015461091281611a6e565b61091c8383611a7b565b505050565b61094b7f93779bf6be703205517715c86297c193472c9d5533e90609b671022041168a4c33610e90565b6109675760405162461bcd60e51b81526004016105a890612649565b4761097b6001600160a01b03831682611aff565b816001600160a01b03167feaff4b37086828766ad3268786972c0cd24259d4c87a80f9d3963a3c3d999b0d826040516109b691815260200190565b60405180910390a25050565b6109da6000805160206129ea83398151915233610e90565b6109f65760405162461bcd60e51b81526004016105a8906123a7565b6001600160a01b03821660009081526001602052604081208054610a19906123ec565b905011610a385760405162461bcd60e51b81526004016105a890612426565b6001600160a01b03818116600090815260026020526040902054811690831614610ab55760405162461bcd60e51b815260206004820152602860248201527f4761734d6f6e6574697a6174696f6e3a20636f6e7472616374206e6f7420726560448201526719da5cdd195c995960c21b60648201526084016105a8565b6001600160a01b038216600090815260016020908152604080832060020180548251818502810185019093528083529192909190830182828015610b2257602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610b04575b505050506001600160a01b0385166000908152600160205260408120929350610b4f926002019150611fda565b6001600160a01b038216600090815260026020526040812080546001600160a01b03191690555b8151811015610c3757826001600160a01b0316828281518110610b9b57610b9b61246d565b60200260200101516001600160a01b031614610c275760016000856001600160a01b03166001600160a01b03168152602001908152602001600020600201828281518110610beb57610beb61246d565b60209081029190910181015182546001810184556000938452919092200180546001600160a01b0319166001600160a01b039092169190911790555b610c3081612499565b9050610b76565b50816001600160a01b0316836001600160a01b03167f7e34a46ef4198698665986c9eda106ae01cd62c67a1ddd1995516462aa77139360405160405180910390a3505050565b6001600160a01b0381163314610ced5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084016105a8565b610cf78282611c18565b5050565b610d06600033610e90565b610d225760405162461bcd60e51b81526004016105a89061268b565b60068190556040518181527f8121fd2868e943e2754ac56b5980c9d40f6d1a98048aa242373c30c8d63542d0906020015b60405180910390a150565b610d766000805160206129ea83398151915233610e90565b610d925760405162461bcd60e51b81526004016105a8906123a7565b6001600160a01b03821660009081526001602052604081208054610db5906123ec565b905011610dd45760405162461bcd60e51b81526004016105a890612426565b6001600160a01b038181166000908152600260205260409020541615610e0c5760405162461bcd60e51b81526004016105a8906126c2565b6001600160a01b038083166000818152600160208181526040808420600290810180549485018155855282852090930180549688166001600160a01b03199788168117909155808552929091528083208054909516841790945592517f7c1a186c94610c708ec37b603a7b15fc83037e1e1899d0738c534a22407d878f9190a35050565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b610ec4600033610e90565b610ee05760405162461bcd60e51b81526004016105a89061268b565b60058190556040518181527e209f2b72d564f415b7b96764fdee7ecf5f45854745e582a224b9a1a1ba1ddc90602001610d53565b610f2c6000805160206129ea83398151915233610e90565b610f485760405162461bcd60e51b81526004016105a8906123a7565b60005b6001600160a01b038416600090815260016020526040902060020154811015610fe2576001600160a01b03841660009081526001602052604081206002908101805491929184908110610fa057610fa061246d565b60009182526020808320909101546001600160a01b03168352820192909252604001902080546001600160a01b0319169055610fdb81612499565b9050610f4b565b5060005b818110156111055760006002818585858181106110055761100561246d565b905060200201602081019061101a9190612104565b6001600160a01b03908116825260208201929092526040016000205416146110985760405162461bcd60e51b815260206004820152602b60248201527f4761734d6f6e6574697a6174696f6e3a2070726f6a65637420616c726561647960448201526a081c9959da5cdd195c995960aa1b60648201526084016105a8565b83600260008585858181106110af576110af61246d565b90506020020160208101906110c49190612104565b6001600160a01b039081168252602082019290925260400160002080546001600160a01b031916929091169190911790556110fe81612499565b9050610fe6565b506001600160a01b038316600090815260016020526040902061112c906002018383611ff8565b506001600160a01b0383166000818152600160205260409081902090517fc34d634fde0d2a5084f7dec1eb890b6baa5c469e189c988371c2078d82d8a0b3916108ea91600290910190612757565b6111a47f93779bf6be703205517715c86297c193472c9d5533e90609b671022041168a4c33610e90565b6111c05760405162461bcd60e51b81526004016105a890612649565b61097b6001600160a01b03831682611aff565b6111de600033610e90565b6111fa5760405162461bcd60e51b81526004016105a89061268b565b60048190556040518181527f6d21826867e00c5860f2c41ce6ab260d9b1e0083d852c2fcf38ae8aa983cc4c490602001610d53565b60008281526020819052604090206001015461124a81611a6e565b61091c8383611c18565b336000908152600160205260408120805461126e906123ec565b9050116112c85760405162461bcd60e51b815260206004820152602260248201527f4761734d6f6e6574697a6174696f6e3a206e6f742070726f6a656374206f776e60448201526132b960f11b60648201526084016105a8565b336000908152600160208181526040808420909201546007909152912054600354158015906112f8575060035482105b801561130e575060045461130c834361276a565b115b80156113245750600454611322824361276a565b115b61137f5760405162461bcd60e51b815260206004820152602660248201527f4761734d6f6e6574697a6174696f6e3a206d757374207761697420746f20776960448201526574686472617760d01b60648201526084016105a8565b80156113c45761138e33611c7d565b60405181815233907fc04d7db2ae23be2ba46893b43d7c4af2fc045905461f3df891e1d6c4d0683ef69060200160405180910390a25b33600081815260076020908152604091829020439081905591519182527fe670e4e82118d22a1f9ee18920455ebc958bae26a90a05d31d3378788b1b0e4491016109b6565b6114216000805160206129ea83398151915233610e90565b61143d5760405162461bcd60e51b81526004016105a8906123a7565b8261145a5760405162461bcd60e51b81526004016105a8906124b2565b6001600160a01b0385166000908152600160205260409020805461147d906123ec565b1590506114cc5760405162461bcd60e51b815260206004820152601f60248201527f4761734d6f6e6574697a6174696f6e3a2070726f6a656374206578697374730060448201526064016105a8565b604051806060016040528085858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525093855250505060208083019190915260408051858302818101840183528682529190930192918691869182919085019084908082843760009201829052509390945250506001600160a01b038816815260016020526040902082519091508190611573908261277d565b50602082810151600183015560408301518051611596926002850192019061205b565b5090505060005b818110156116785760006002818585858181106115bc576115bc61246d565b90506020020160208101906115d19190612104565b6001600160a01b039081168252602082019290925260400160002054161461160b5760405162461bcd60e51b81526004016105a8906126c2565b85600260008585858181106116225761162261246d565b90506020020160208101906116379190612104565b6001600160a01b039081168252602082019290925260400160002080546001600160a01b0319169290911691909117905561167181612499565b905061159d565b506001600160a01b0385166000818152600160205260409081902090517fd67e812e4046dc0df638cf5dd5e6eb8ae397a13d7a9da0090a65742b6fd91d71916116c591600282019061283d565b60405180910390a25050505050565b6116fe7fb7afb381c2ec32313122d8bf9a9482db2de1a2e999efd75492ca6194dae14f3d33610e90565b61175d5760405162461bcd60e51b815260206004820152602a60248201527f4761734d6f6e6574697a6174696f6e3a206e6f742072657761726473206461746044820152693090383937bb34b232b960b11b60648201526084016105a8565b6001600160a01b03831660009081526007602052604090205482146117d35760405162461bcd60e51b815260206004820152602660248201527f4761734d6f6e6574697a6174696f6e3a206e6f207769746864726177616c2072604482015265195c5d595cdd60d21b60648201526084016105a8565b600081116118325760405162461bcd60e51b815260206004820152602660248201527f4761734d6f6e6574697a6174696f6e3a206e6f20616d6f756e7420746f20776960448201526574686472617760d01b60648201526084016105a8565b6001600160a01b0383166000908152600760209081526040808320338452600281019092529091205460ff16156118b65760405162461bcd60e51b815260206004820152602260248201527f4761734d6f6e6574697a6174696f6e3a20616c726561647920636f6e6669726d604482015261195960f21b60648201526084016105a8565b6001810180549060006118c883612499565b9091555050600381018054600180820183556000928352602080842090920180546001600160a01b0319163390811790915583526002840182526040808420805460ff19169092179091558483526004840190915281205490036119415760058101805460018101825560009182526020909120018290555b6000828152600482016020526040812080549161195d83612499565b90915550506005546000838152600483016020526040902054106119f85761198484611c7d565b6001600160a01b0384166000818152600160208190526040909120439101556119ad9083611aff565b60408051848152602081018490526001600160a01b038616917f35fc39e80f531e18729cd92611935c06db664fc014e88f0b60f14699df88377b91015b60405180910390a250505050565b6005548160010154118015611a1f57506006546005548260010154611a1d919061276a565b115b15611a6857611a2d84611c7d565b836001600160a01b03167fc04d7db2ae23be2ba46893b43d7c4af2fc045905461f3df891e1d6c4d0683ef6846040516119ea91815260200190565b50505050565b611a788133611d92565b50565b611a858282610e90565b610cf7576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055611abb3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b80471015611b4f5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e636500000060448201526064016105a8565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114611b9c576040519150601f19603f3d011682016040523d82523d6000602084013e611ba1565b606091505b505090508061091c5760405162461bcd60e51b815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d6179206861766520726576657274656400000000000060648201526084016105a8565b611c228282610e90565b15610cf7576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b6001600160a01b0381166000908152600760205260408120905b6005820154811015611cec57816004016000836005018381548110611cbe57611cbe61246d565b906000526020600020015481526020019081526020016000206000905580611ce590612499565b9050611c97565b5060005b6003820154811015611d5357816002016000836003018381548110611d1757611d1761246d565b60009182526020808320909101546001600160a01b031683528201929092526040019020805460ff19169055611d4c81612499565b9050611cf0565b506001600160a01b03821660009081526007602052604081208181556001810182905590611d846003830182611fda565b611a68600583016000611fda565b611d9c8282610e90565b610cf757611da981611deb565b611db4836020611dfd565b604051602001611dc5929190612900565b60408051601f198184030181529082905262461bcd60e51b82526105a891600401612975565b606061066d6001600160a01b03831660145b60606000611e0c8360026129a8565b611e179060026129bf565b67ffffffffffffffff811115611e2f57611e2f6124f5565b6040519080825280601f01601f191660200182016040528015611e59576020820181803683370190505b509050600360fc1b81600081518110611e7457611e7461246d565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110611ea357611ea361246d565b60200101906001600160f81b031916908160001a9053506000611ec78460026129a8565b611ed29060016129bf565b90505b6001811115611f4a576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110611f0657611f0661246d565b1a60f81b828281518110611f1c57611f1c61246d565b60200101906001600160f81b031916908160001a90535060049490941c93611f43816129d2565b9050611ed5565b508315611f995760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e7460448201526064016105a8565b9392505050565b508054611fac906123ec565b6000825580601f10611fbc575050565b601f016020900490600052602060002090810190611a7891906120b0565b5080546000825590600052602060002090810190611a7891906120b0565b82805482825590600052602060002090810192821561204b579160200282015b8281111561204b5781546001600160a01b0319166001600160a01b03843516178255602090920191600190910190612018565b506120579291506120b0565b5090565b82805482825590600052602060002090810192821561204b579160200282015b8281111561204b57825182546001600160a01b0319166001600160a01b0390911617825560209092019160019091019061207b565b5b8082111561205757600081556001016120b1565b6000602082840312156120d757600080fd5b81356001600160e01b031981168114611f9957600080fd5b6001600160a01b0381168114611a7857600080fd5b60006020828403121561211657600080fd5b8135611f99816120ef565b60008083601f84011261213357600080fd5b50813567ffffffffffffffff81111561214b57600080fd5b60208301915083602082850101111561216357600080fd5b9250929050565b60008060006040848603121561217f57600080fd5b833561218a816120ef565b9250602084013567ffffffffffffffff8111156121a657600080fd5b6121b286828701612121565b9497909650939450505050565b6000602082840312156121d157600080fd5b5035919050565b600080604083850312156121eb57600080fd5b8235915060208301356121fd816120ef565b809150509250929050565b6000806040838503121561221b57600080fd5b8235612226816120ef565b915060208301356121fd816120ef565b60008083601f84011261224857600080fd5b50813567ffffffffffffffff81111561226057600080fd5b6020830191508360208260051b850101111561216357600080fd5b60008060006040848603121561229057600080fd5b833561229b816120ef565b9250602084013567ffffffffffffffff8111156122b757600080fd5b6121b286828701612236565b600080604083850312156122d657600080fd5b82356122e1816120ef565b946020939093013593505050565b60008060008060006060868803121561230757600080fd5b8535612312816120ef565b9450602086013567ffffffffffffffff8082111561232f57600080fd5b61233b89838a01612121565b9096509450604088013591508082111561235457600080fd5b5061236188828901612236565b969995985093965092949392505050565b60008060006060848603121561238757600080fd5b8335612392816120ef565b95602085013595506040909401359392505050565b60208082526025908201527f4761734d6f6e6574697a6174696f6e3a206e6f742070726f6a65637473206d616040820152643730b3b2b960d91b606082015260800190565b600181811c9082168061240057607f821691505b60208210810361242057634e487b7160e01b600052602260045260246000fd5b50919050565b60208082526027908201527f4761734d6f6e6574697a6174696f6e3a2070726f6a65637420646f6573206e6f6040820152661d08195e1a5cdd60ca1b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016124ab576124ab612483565b5060010190565b60208082526023908201527f4761734d6f6e6574697a6174696f6e3a20656d707479206d657461646174612060408201526275726960e81b606082015260800190565b634e487b7160e01b600052604160045260246000fd5b601f82111561091c57600081815260208120601f850160051c810160208610156125325750805b601f850160051c820191505b818110156125515782815560010161253e565b505050505050565b67ffffffffffffffff831115612571576125716124f5565b6125858361257f83546123ec565b8361250b565b6000601f8411600181146125b957600085156125a15750838201355b600019600387901b1c1916600186901b178355612613565b600083815260209020601f19861690835b828110156125ea57868501358255602094850194600190920191016125ca565b50868210156126075760001960f88860031b161c19848701351681555b505060018560011b0183555b5050505050565b60208152816020820152818360408301376000818301604090810191909152601f909201601f19160101919050565b60208082526022908201527f4761734d6f6e6574697a6174696f6e3a206e6f742066756e6473206d616e616760408201526132b960f11b606082015260800190565b6020808252601a908201527f4761734d6f6e6574697a6174696f6e3a206e6f742061646d696e000000000000604082015260600190565b6020808252602c908201527f4761734d6f6e6574697a6174696f6e3a20636f6e747261637420616c7265616460408201526b1e481c9959da5cdd195c995960a21b606082015260800190565b6000815480845260208085019450836000528060002060005b8381101561274c5781546001600160a01b031687529582019560019182019101612727565b509495945050505050565b602081526000611f99602083018461270e565b8181038181111561066d5761066d612483565b815167ffffffffffffffff811115612797576127976124f5565b6127ab816127a584546123ec565b8461250b565b602080601f8311600181146127e057600084156127c85750858301515b600019600386901b1c1916600185901b178555612551565b600085815260208120601f198616915b8281101561280f578886015182559484019460019091019084016127f0565b508582101561282d5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60408152600080845461284f816123ec565b8060408601526060600180841660008114612871576001811461288b576128bc565b60ff1985168884015283151560051b8801830195506128bc565b8960005260208060002060005b868110156128b35781548b8201870152908401908201612898565b8a018501975050505b505050505082810360208401526128d3818561270e565b95945050505050565b60005b838110156128f75781810151838201526020016128df565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516129388160178501602088016128dc565b7001034b99036b4b9b9b4b733903937b6329607d1b60179184019182015283516129698160288401602088016128dc565b01602801949350505050565b60208152600082518060208401526129948160408501602087016128dc565b601f01601f19169190910160400192915050565b808202811582820484141761066d5761066d612483565b8082018082111561066d5761066d612483565b6000816129e1576129e1612483565b50600019019056fe979b77ba2fd37b608c52b1185e9b8e96ba2ff2e0c1dff47d2959620ef0ab3861a26469706673582212205cfd0a3a531265fa6b8edc2eb9d683da783c8288ab53f79f5566a001d970490564736f6c63430008130033",
}

// GasMonetizationABI is the input ABI used to generate the binding from.
// Deprecated: Use GasMonetizationMetaData.ABI instead.
var GasMonetizationABI = GasMonetizationMetaData.ABI

// GasMonetizationBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use GasMonetizationMetaData.Bin instead.
var GasMonetizationBin = GasMonetizationMetaData.Bin

// DeployGasMonetization deploys a new Ethereum contract, binding an instance of GasMonetization to it.
func DeployGasMonetization(auth *bind.TransactOpts, backend bind.ContractBackend, withdrawalBlocksFrequencyLimit *big.Int, confirmationsToMakeWithdrawal *big.Int, allowedConfirmationsDeviation *big.Int) (common.Address, *types.Transaction, *GasMonetization, error) {
	parsed, err := GasMonetizationMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(GasMonetizationBin), backend, withdrawalBlocksFrequencyLimit, confirmationsToMakeWithdrawal, allowedConfirmationsDeviation)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &GasMonetization{GasMonetizationCaller: GasMonetizationCaller{contract: contract}, GasMonetizationTransactor: GasMonetizationTransactor{contract: contract}, GasMonetizationFilterer: GasMonetizationFilterer{contract: contract}}, nil
}

// GasMonetization is an auto generated Go binding around an Ethereum contract.
type GasMonetization struct {
	GasMonetizationCaller     // Read-only binding to the contract
	GasMonetizationTransactor // Write-only binding to the contract
	GasMonetizationFilterer   // Log filterer for contract events
}

// GasMonetizationCaller is an auto generated read-only Go binding around an Ethereum contract.
type GasMonetizationCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// GasMonetizationTransactor is an auto generated write-only Go binding around an Ethereum contract.
type GasMonetizationTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// GasMonetizationFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type GasMonetizationFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// GasMonetizationSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type GasMonetizationSession struct {
	Contract     *GasMonetization  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// GasMonetizationCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type GasMonetizationCallerSession struct {
	Contract *GasMonetizationCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// GasMonetizationTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type GasMonetizationTransactorSession struct {
	Contract     *GasMonetizationTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// GasMonetizationRaw is an auto generated low-level Go binding around an Ethereum contract.
type GasMonetizationRaw struct {
	Contract *GasMonetization // Generic contract binding to access the raw methods on
}

// GasMonetizationCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type GasMonetizationCallerRaw struct {
	Contract *GasMonetizationCaller // Generic read-only contract binding to access the raw methods on
}

// GasMonetizationTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type GasMonetizationTransactorRaw struct {
	Contract *GasMonetizationTransactor // Generic write-only contract binding to access the raw methods on
}

// NewGasMonetization creates a new instance of GasMonetization, bound to a specific deployed contract.
func NewGasMonetization(address common.Address, backend bind.ContractBackend) (*GasMonetization, error) {
	contract, err := bindGasMonetization(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &GasMonetization{GasMonetizationCaller: GasMonetizationCaller{contract: contract}, GasMonetizationTransactor: GasMonetizationTransactor{contract: contract}, GasMonetizationFilterer: GasMonetizationFilterer{contract: contract}}, nil
}

// NewGasMonetizationCaller creates a new read-only instance of GasMonetization, bound to a specific deployed contract.
func NewGasMonetizationCaller(address common.Address, caller bind.ContractCaller) (*GasMonetizationCaller, error) {
	contract, err := bindGasMonetization(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationCaller{contract: contract}, nil
}

// NewGasMonetizationTransactor creates a new write-only instance of GasMonetization, bound to a specific deployed contract.
func NewGasMonetizationTransactor(address common.Address, transactor bind.ContractTransactor) (*GasMonetizationTransactor, error) {
	contract, err := bindGasMonetization(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationTransactor{contract: contract}, nil
}

// NewGasMonetizationFilterer creates a new log filterer instance of GasMonetization, bound to a specific deployed contract.
func NewGasMonetizationFilterer(address common.Address, filterer bind.ContractFilterer) (*GasMonetizationFilterer, error) {
	contract, err := bindGasMonetization(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationFilterer{contract: contract}, nil
}

// bindGasMonetization binds a generic wrapper to an already deployed contract.
func bindGasMonetization(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := GasMonetizationMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_GasMonetization *GasMonetizationRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _GasMonetization.Contract.GasMonetizationCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_GasMonetization *GasMonetizationRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasMonetization.Contract.GasMonetizationTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_GasMonetization *GasMonetizationRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _GasMonetization.Contract.GasMonetizationTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_GasMonetization *GasMonetizationCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _GasMonetization.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_GasMonetization *GasMonetizationTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasMonetization.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_GasMonetization *GasMonetizationTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _GasMonetization.Contract.contract.Transact(opts, method, params...)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "DEFAULT_ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _GasMonetization.Contract.DEFAULTADMINROLE(&_GasMonetization.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _GasMonetization.Contract.DEFAULTADMINROLE(&_GasMonetization.CallOpts)
}

// FUNDERROLE is a free data retrieval call binding the contract method 0x34aedecd.
//
// Solidity: function FUNDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) FUNDERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "FUNDER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// FUNDERROLE is a free data retrieval call binding the contract method 0x34aedecd.
//
// Solidity: function FUNDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) FUNDERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.FUNDERROLE(&_GasMonetization.CallOpts)
}

// FUNDERROLE is a free data retrieval call binding the contract method 0x34aedecd.
//
// Solidity: function FUNDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) FUNDERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.FUNDERROLE(&_GasMonetization.CallOpts)
}

// FUNDSMANAGERROLE is a free data retrieval call binding the contract method 0xc4707a83.
//
// Solidity: function FUNDS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) FUNDSMANAGERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "FUNDS_MANAGER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// FUNDSMANAGERROLE is a free data retrieval call binding the contract method 0xc4707a83.
//
// Solidity: function FUNDS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) FUNDSMANAGERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.FUNDSMANAGERROLE(&_GasMonetization.CallOpts)
}

// FUNDSMANAGERROLE is a free data retrieval call binding the contract method 0xc4707a83.
//
// Solidity: function FUNDS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) FUNDSMANAGERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.FUNDSMANAGERROLE(&_GasMonetization.CallOpts)
}

// PROJECTSMANAGERROLE is a free data retrieval call binding the contract method 0x571e8697.
//
// Solidity: function PROJECTS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) PROJECTSMANAGERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "PROJECTS_MANAGER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// PROJECTSMANAGERROLE is a free data retrieval call binding the contract method 0x571e8697.
//
// Solidity: function PROJECTS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) PROJECTSMANAGERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.PROJECTSMANAGERROLE(&_GasMonetization.CallOpts)
}

// PROJECTSMANAGERROLE is a free data retrieval call binding the contract method 0x571e8697.
//
// Solidity: function PROJECTS_MANAGER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) PROJECTSMANAGERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.PROJECTSMANAGERROLE(&_GasMonetization.CallOpts)
}

// REWARDSDATAPROVIDERROLE is a free data retrieval call binding the contract method 0x9bfbca44.
//
// Solidity: function REWARDS_DATA_PROVIDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) REWARDSDATAPROVIDERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "REWARDS_DATA_PROVIDER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// REWARDSDATAPROVIDERROLE is a free data retrieval call binding the contract method 0x9bfbca44.
//
// Solidity: function REWARDS_DATA_PROVIDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) REWARDSDATAPROVIDERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.REWARDSDATAPROVIDERROLE(&_GasMonetization.CallOpts)
}

// REWARDSDATAPROVIDERROLE is a free data retrieval call binding the contract method 0x9bfbca44.
//
// Solidity: function REWARDS_DATA_PROVIDER_ROLE() view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) REWARDSDATAPROVIDERROLE() ([32]byte, error) {
	return _GasMonetization.Contract.REWARDSDATAPROVIDERROLE(&_GasMonetization.CallOpts)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_GasMonetization *GasMonetizationCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_GasMonetization *GasMonetizationSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _GasMonetization.Contract.GetRoleAdmin(&_GasMonetization.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_GasMonetization *GasMonetizationCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _GasMonetization.Contract.GetRoleAdmin(&_GasMonetization.CallOpts, role)
}

// HasPendingWithdrawal is a free data retrieval call binding the contract method 0xd7885615.
//
// Solidity: function hasPendingWithdrawal(address owner, uint256 blockId) view returns(bool)
func (_GasMonetization *GasMonetizationCaller) HasPendingWithdrawal(opts *bind.CallOpts, owner common.Address, blockId *big.Int) (bool, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "hasPendingWithdrawal", owner, blockId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasPendingWithdrawal is a free data retrieval call binding the contract method 0xd7885615.
//
// Solidity: function hasPendingWithdrawal(address owner, uint256 blockId) view returns(bool)
func (_GasMonetization *GasMonetizationSession) HasPendingWithdrawal(owner common.Address, blockId *big.Int) (bool, error) {
	return _GasMonetization.Contract.HasPendingWithdrawal(&_GasMonetization.CallOpts, owner, blockId)
}

// HasPendingWithdrawal is a free data retrieval call binding the contract method 0xd7885615.
//
// Solidity: function hasPendingWithdrawal(address owner, uint256 blockId) view returns(bool)
func (_GasMonetization *GasMonetizationCallerSession) HasPendingWithdrawal(owner common.Address, blockId *big.Int) (bool, error) {
	return _GasMonetization.Contract.HasPendingWithdrawal(&_GasMonetization.CallOpts, owner, blockId)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_GasMonetization *GasMonetizationCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_GasMonetization *GasMonetizationSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _GasMonetization.Contract.HasRole(&_GasMonetization.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_GasMonetization *GasMonetizationCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _GasMonetization.Contract.HasRole(&_GasMonetization.CallOpts, role, account)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_GasMonetization *GasMonetizationCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _GasMonetization.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_GasMonetization *GasMonetizationSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _GasMonetization.Contract.SupportsInterface(&_GasMonetization.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_GasMonetization *GasMonetizationCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _GasMonetization.Contract.SupportsInterface(&_GasMonetization.CallOpts, interfaceId)
}

// AddFunds is a paid mutator transaction binding the contract method 0xa26759cb.
//
// Solidity: function addFunds() payable returns()
func (_GasMonetization *GasMonetizationTransactor) AddFunds(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "addFunds")
}

// AddFunds is a paid mutator transaction binding the contract method 0xa26759cb.
//
// Solidity: function addFunds() payable returns()
func (_GasMonetization *GasMonetizationSession) AddFunds() (*types.Transaction, error) {
	return _GasMonetization.Contract.AddFunds(&_GasMonetization.TransactOpts)
}

// AddFunds is a paid mutator transaction binding the contract method 0xa26759cb.
//
// Solidity: function addFunds() payable returns()
func (_GasMonetization *GasMonetizationTransactorSession) AddFunds() (*types.Transaction, error) {
	return _GasMonetization.Contract.AddFunds(&_GasMonetization.TransactOpts)
}

// AddProject is a paid mutator transaction binding the contract method 0xe9ba64a7.
//
// Solidity: function addProject(address owner, string metadataUri, address[] contracts) returns()
func (_GasMonetization *GasMonetizationTransactor) AddProject(opts *bind.TransactOpts, owner common.Address, metadataUri string, contracts []common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "addProject", owner, metadataUri, contracts)
}

// AddProject is a paid mutator transaction binding the contract method 0xe9ba64a7.
//
// Solidity: function addProject(address owner, string metadataUri, address[] contracts) returns()
func (_GasMonetization *GasMonetizationSession) AddProject(owner common.Address, metadataUri string, contracts []common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.AddProject(&_GasMonetization.TransactOpts, owner, metadataUri, contracts)
}

// AddProject is a paid mutator transaction binding the contract method 0xe9ba64a7.
//
// Solidity: function addProject(address owner, string metadataUri, address[] contracts) returns()
func (_GasMonetization *GasMonetizationTransactorSession) AddProject(owner common.Address, metadataUri string, contracts []common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.AddProject(&_GasMonetization.TransactOpts, owner, metadataUri, contracts)
}

// AddProjectContract is a paid mutator transaction binding the contract method 0x79612e3a.
//
// Solidity: function addProjectContract(address owner, address contractAddress) returns()
func (_GasMonetization *GasMonetizationTransactor) AddProjectContract(opts *bind.TransactOpts, owner common.Address, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "addProjectContract", owner, contractAddress)
}

// AddProjectContract is a paid mutator transaction binding the contract method 0x79612e3a.
//
// Solidity: function addProjectContract(address owner, address contractAddress) returns()
func (_GasMonetization *GasMonetizationSession) AddProjectContract(owner common.Address, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.AddProjectContract(&_GasMonetization.TransactOpts, owner, contractAddress)
}

// AddProjectContract is a paid mutator transaction binding the contract method 0x79612e3a.
//
// Solidity: function addProjectContract(address owner, address contractAddress) returns()
func (_GasMonetization *GasMonetizationTransactorSession) AddProjectContract(owner common.Address, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.AddProjectContract(&_GasMonetization.TransactOpts, owner, contractAddress)
}

// CompleteWithdrawal is a paid mutator transaction binding the contract method 0xfc07244f.
//
// Solidity: function completeWithdrawal(address owner, uint256 blockNumber, uint256 amount) returns()
func (_GasMonetization *GasMonetizationTransactor) CompleteWithdrawal(opts *bind.TransactOpts, owner common.Address, blockNumber *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "completeWithdrawal", owner, blockNumber, amount)
}

// CompleteWithdrawal is a paid mutator transaction binding the contract method 0xfc07244f.
//
// Solidity: function completeWithdrawal(address owner, uint256 blockNumber, uint256 amount) returns()
func (_GasMonetization *GasMonetizationSession) CompleteWithdrawal(owner common.Address, blockNumber *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.CompleteWithdrawal(&_GasMonetization.TransactOpts, owner, blockNumber, amount)
}

// CompleteWithdrawal is a paid mutator transaction binding the contract method 0xfc07244f.
//
// Solidity: function completeWithdrawal(address owner, uint256 blockNumber, uint256 amount) returns()
func (_GasMonetization *GasMonetizationTransactorSession) CompleteWithdrawal(owner common.Address, blockNumber *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.CompleteWithdrawal(&_GasMonetization.TransactOpts, owner, blockNumber, amount)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.GrantRole(&_GasMonetization.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.GrantRole(&_GasMonetization.TransactOpts, role, account)
}

// RemoveProject is a paid mutator transaction binding the contract method 0x0c0ad299.
//
// Solidity: function removeProject(address owner) returns()
func (_GasMonetization *GasMonetizationTransactor) RemoveProject(opts *bind.TransactOpts, owner common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "removeProject", owner)
}

// RemoveProject is a paid mutator transaction binding the contract method 0x0c0ad299.
//
// Solidity: function removeProject(address owner) returns()
func (_GasMonetization *GasMonetizationSession) RemoveProject(owner common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RemoveProject(&_GasMonetization.TransactOpts, owner)
}

// RemoveProject is a paid mutator transaction binding the contract method 0x0c0ad299.
//
// Solidity: function removeProject(address owner) returns()
func (_GasMonetization *GasMonetizationTransactorSession) RemoveProject(owner common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RemoveProject(&_GasMonetization.TransactOpts, owner)
}

// RemoveProjectContract is a paid mutator transaction binding the contract method 0x3449b5b4.
//
// Solidity: function removeProjectContract(address owner, address contractAddress) returns()
func (_GasMonetization *GasMonetizationTransactor) RemoveProjectContract(opts *bind.TransactOpts, owner common.Address, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "removeProjectContract", owner, contractAddress)
}

// RemoveProjectContract is a paid mutator transaction binding the contract method 0x3449b5b4.
//
// Solidity: function removeProjectContract(address owner, address contractAddress) returns()
func (_GasMonetization *GasMonetizationSession) RemoveProjectContract(owner common.Address, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RemoveProjectContract(&_GasMonetization.TransactOpts, owner, contractAddress)
}

// RemoveProjectContract is a paid mutator transaction binding the contract method 0x3449b5b4.
//
// Solidity: function removeProjectContract(address owner, address contractAddress) returns()
func (_GasMonetization *GasMonetizationTransactorSession) RemoveProjectContract(owner common.Address, contractAddress common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RemoveProjectContract(&_GasMonetization.TransactOpts, owner, contractAddress)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "renounceRole", role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RenounceRole(&_GasMonetization.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactorSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RenounceRole(&_GasMonetization.TransactOpts, role, account)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0xdbaf2145.
//
// Solidity: function requestWithdrawal() returns()
func (_GasMonetization *GasMonetizationTransactor) RequestWithdrawal(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "requestWithdrawal")
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0xdbaf2145.
//
// Solidity: function requestWithdrawal() returns()
func (_GasMonetization *GasMonetizationSession) RequestWithdrawal() (*types.Transaction, error) {
	return _GasMonetization.Contract.RequestWithdrawal(&_GasMonetization.TransactOpts)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0xdbaf2145.
//
// Solidity: function requestWithdrawal() returns()
func (_GasMonetization *GasMonetizationTransactorSession) RequestWithdrawal() (*types.Transaction, error) {
	return _GasMonetization.Contract.RequestWithdrawal(&_GasMonetization.TransactOpts)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RevokeRole(&_GasMonetization.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_GasMonetization *GasMonetizationTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.RevokeRole(&_GasMonetization.TransactOpts, role, account)
}

// SetProjectContracts is a paid mutator transaction binding the contract method 0xa6db775b.
//
// Solidity: function setProjectContracts(address owner, address[] contracts) returns()
func (_GasMonetization *GasMonetizationTransactor) SetProjectContracts(opts *bind.TransactOpts, owner common.Address, contracts []common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "setProjectContracts", owner, contracts)
}

// SetProjectContracts is a paid mutator transaction binding the contract method 0xa6db775b.
//
// Solidity: function setProjectContracts(address owner, address[] contracts) returns()
func (_GasMonetization *GasMonetizationSession) SetProjectContracts(owner common.Address, contracts []common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.SetProjectContracts(&_GasMonetization.TransactOpts, owner, contracts)
}

// SetProjectContracts is a paid mutator transaction binding the contract method 0xa6db775b.
//
// Solidity: function setProjectContracts(address owner, address[] contracts) returns()
func (_GasMonetization *GasMonetizationTransactorSession) SetProjectContracts(owner common.Address, contracts []common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.SetProjectContracts(&_GasMonetization.TransactOpts, owner, contracts)
}

// UpdateProjectMetadataUri is a paid mutator transaction binding the contract method 0x191ba54e.
//
// Solidity: function updateProjectMetadataUri(address owner, string metadataUri) returns()
func (_GasMonetization *GasMonetizationTransactor) UpdateProjectMetadataUri(opts *bind.TransactOpts, owner common.Address, metadataUri string) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "updateProjectMetadataUri", owner, metadataUri)
}

// UpdateProjectMetadataUri is a paid mutator transaction binding the contract method 0x191ba54e.
//
// Solidity: function updateProjectMetadataUri(address owner, string metadataUri) returns()
func (_GasMonetization *GasMonetizationSession) UpdateProjectMetadataUri(owner common.Address, metadataUri string) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateProjectMetadataUri(&_GasMonetization.TransactOpts, owner, metadataUri)
}

// UpdateProjectMetadataUri is a paid mutator transaction binding the contract method 0x191ba54e.
//
// Solidity: function updateProjectMetadataUri(address owner, string metadataUri) returns()
func (_GasMonetization *GasMonetizationTransactorSession) UpdateProjectMetadataUri(owner common.Address, metadataUri string) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateProjectMetadataUri(&_GasMonetization.TransactOpts, owner, metadataUri)
}

// UpdateWithdrawalAllowedConfirmationsDeviation is a paid mutator transaction binding the contract method 0x3c18315e.
//
// Solidity: function updateWithdrawalAllowedConfirmationsDeviation(uint256 limit) returns()
func (_GasMonetization *GasMonetizationTransactor) UpdateWithdrawalAllowedConfirmationsDeviation(opts *bind.TransactOpts, limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "updateWithdrawalAllowedConfirmationsDeviation", limit)
}

// UpdateWithdrawalAllowedConfirmationsDeviation is a paid mutator transaction binding the contract method 0x3c18315e.
//
// Solidity: function updateWithdrawalAllowedConfirmationsDeviation(uint256 limit) returns()
func (_GasMonetization *GasMonetizationSession) UpdateWithdrawalAllowedConfirmationsDeviation(limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateWithdrawalAllowedConfirmationsDeviation(&_GasMonetization.TransactOpts, limit)
}

// UpdateWithdrawalAllowedConfirmationsDeviation is a paid mutator transaction binding the contract method 0x3c18315e.
//
// Solidity: function updateWithdrawalAllowedConfirmationsDeviation(uint256 limit) returns()
func (_GasMonetization *GasMonetizationTransactorSession) UpdateWithdrawalAllowedConfirmationsDeviation(limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateWithdrawalAllowedConfirmationsDeviation(&_GasMonetization.TransactOpts, limit)
}

// UpdateWithdrawalBlocksFrequencyLimit is a paid mutator transaction binding the contract method 0xc11173fe.
//
// Solidity: function updateWithdrawalBlocksFrequencyLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationTransactor) UpdateWithdrawalBlocksFrequencyLimit(opts *bind.TransactOpts, limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "updateWithdrawalBlocksFrequencyLimit", limit)
}

// UpdateWithdrawalBlocksFrequencyLimit is a paid mutator transaction binding the contract method 0xc11173fe.
//
// Solidity: function updateWithdrawalBlocksFrequencyLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationSession) UpdateWithdrawalBlocksFrequencyLimit(limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateWithdrawalBlocksFrequencyLimit(&_GasMonetization.TransactOpts, limit)
}

// UpdateWithdrawalBlocksFrequencyLimit is a paid mutator transaction binding the contract method 0xc11173fe.
//
// Solidity: function updateWithdrawalBlocksFrequencyLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationTransactorSession) UpdateWithdrawalBlocksFrequencyLimit(limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateWithdrawalBlocksFrequencyLimit(&_GasMonetization.TransactOpts, limit)
}

// UpdateWithdrawalConfirmationsLimit is a paid mutator transaction binding the contract method 0xa210106f.
//
// Solidity: function updateWithdrawalConfirmationsLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationTransactor) UpdateWithdrawalConfirmationsLimit(opts *bind.TransactOpts, limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "updateWithdrawalConfirmationsLimit", limit)
}

// UpdateWithdrawalConfirmationsLimit is a paid mutator transaction binding the contract method 0xa210106f.
//
// Solidity: function updateWithdrawalConfirmationsLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationSession) UpdateWithdrawalConfirmationsLimit(limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateWithdrawalConfirmationsLimit(&_GasMonetization.TransactOpts, limit)
}

// UpdateWithdrawalConfirmationsLimit is a paid mutator transaction binding the contract method 0xa210106f.
//
// Solidity: function updateWithdrawalConfirmationsLimit(uint256 limit) returns()
func (_GasMonetization *GasMonetizationTransactorSession) UpdateWithdrawalConfirmationsLimit(limit *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.UpdateWithdrawalConfirmationsLimit(&_GasMonetization.TransactOpts, limit)
}

// WithdrawAllFunds is a paid mutator transaction binding the contract method 0x32dee40b.
//
// Solidity: function withdrawAllFunds(address recipient) returns()
func (_GasMonetization *GasMonetizationTransactor) WithdrawAllFunds(opts *bind.TransactOpts, recipient common.Address) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "withdrawAllFunds", recipient)
}

// WithdrawAllFunds is a paid mutator transaction binding the contract method 0x32dee40b.
//
// Solidity: function withdrawAllFunds(address recipient) returns()
func (_GasMonetization *GasMonetizationSession) WithdrawAllFunds(recipient common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.WithdrawAllFunds(&_GasMonetization.TransactOpts, recipient)
}

// WithdrawAllFunds is a paid mutator transaction binding the contract method 0x32dee40b.
//
// Solidity: function withdrawAllFunds(address recipient) returns()
func (_GasMonetization *GasMonetizationTransactorSession) WithdrawAllFunds(recipient common.Address) (*types.Transaction, error) {
	return _GasMonetization.Contract.WithdrawAllFunds(&_GasMonetization.TransactOpts, recipient)
}

// WithdrawFunds is a paid mutator transaction binding the contract method 0xc1075329.
//
// Solidity: function withdrawFunds(address recipient, uint256 amount) returns()
func (_GasMonetization *GasMonetizationTransactor) WithdrawFunds(opts *bind.TransactOpts, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.contract.Transact(opts, "withdrawFunds", recipient, amount)
}

// WithdrawFunds is a paid mutator transaction binding the contract method 0xc1075329.
//
// Solidity: function withdrawFunds(address recipient, uint256 amount) returns()
func (_GasMonetization *GasMonetizationSession) WithdrawFunds(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.WithdrawFunds(&_GasMonetization.TransactOpts, recipient, amount)
}

// WithdrawFunds is a paid mutator transaction binding the contract method 0xc1075329.
//
// Solidity: function withdrawFunds(address recipient, uint256 amount) returns()
func (_GasMonetization *GasMonetizationTransactorSession) WithdrawFunds(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _GasMonetization.Contract.WithdrawFunds(&_GasMonetization.TransactOpts, recipient, amount)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_GasMonetization *GasMonetizationTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasMonetization.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_GasMonetization *GasMonetizationSession) Receive() (*types.Transaction, error) {
	return _GasMonetization.Contract.Receive(&_GasMonetization.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_GasMonetization *GasMonetizationTransactorSession) Receive() (*types.Transaction, error) {
	return _GasMonetization.Contract.Receive(&_GasMonetization.TransactOpts)
}

// GasMonetizationContractDeployedIterator is returned from FilterContractDeployed and is used to iterate over the raw logs and unpacked data for ContractDeployed events raised by the GasMonetization contract.
type GasMonetizationContractDeployedIterator struct {
	Event *GasMonetizationContractDeployed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationContractDeployedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationContractDeployed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationContractDeployed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationContractDeployedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationContractDeployedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationContractDeployed represents a ContractDeployed event raised by the GasMonetization contract.
type GasMonetizationContractDeployed struct {
	WithdrawalBlocksFrequencyLimit *big.Int
	ConfirmationsToMakeWithdrawal  *big.Int
	AllowedConfirmationsDeviation  *big.Int
	Raw                            types.Log // Blockchain specific contextual infos
}

// FilterContractDeployed is a free log retrieval operation binding the contract event 0x9d6e529b64d0156dc8d51fd7a5e9e2c55ce73d15e239849a3a796f7e1c33ec81.
//
// Solidity: event ContractDeployed(uint256 withdrawalBlocksFrequencyLimit, uint256 confirmationsToMakeWithdrawal, uint256 allowedConfirmationsDeviation)
func (_GasMonetization *GasMonetizationFilterer) FilterContractDeployed(opts *bind.FilterOpts) (*GasMonetizationContractDeployedIterator, error) {

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ContractDeployed")
	if err != nil {
		return nil, err
	}
	return &GasMonetizationContractDeployedIterator{contract: _GasMonetization.contract, event: "ContractDeployed", logs: logs, sub: sub}, nil
}

// WatchContractDeployed is a free log subscription operation binding the contract event 0x9d6e529b64d0156dc8d51fd7a5e9e2c55ce73d15e239849a3a796f7e1c33ec81.
//
// Solidity: event ContractDeployed(uint256 withdrawalBlocksFrequencyLimit, uint256 confirmationsToMakeWithdrawal, uint256 allowedConfirmationsDeviation)
func (_GasMonetization *GasMonetizationFilterer) WatchContractDeployed(opts *bind.WatchOpts, sink chan<- *GasMonetizationContractDeployed) (event.Subscription, error) {

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ContractDeployed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationContractDeployed)
				if err := _GasMonetization.contract.UnpackLog(event, "ContractDeployed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseContractDeployed is a log parse operation binding the contract event 0x9d6e529b64d0156dc8d51fd7a5e9e2c55ce73d15e239849a3a796f7e1c33ec81.
//
// Solidity: event ContractDeployed(uint256 withdrawalBlocksFrequencyLimit, uint256 confirmationsToMakeWithdrawal, uint256 allowedConfirmationsDeviation)
func (_GasMonetization *GasMonetizationFilterer) ParseContractDeployed(log types.Log) (*GasMonetizationContractDeployed, error) {
	event := new(GasMonetizationContractDeployed)
	if err := _GasMonetization.contract.UnpackLog(event, "ContractDeployed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationFundsAddedIterator is returned from FilterFundsAdded and is used to iterate over the raw logs and unpacked data for FundsAdded events raised by the GasMonetization contract.
type GasMonetizationFundsAddedIterator struct {
	Event *GasMonetizationFundsAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationFundsAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationFundsAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationFundsAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationFundsAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationFundsAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationFundsAdded represents a FundsAdded event raised by the GasMonetization contract.
type GasMonetizationFundsAdded struct {
	Funder common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterFundsAdded is a free log retrieval operation binding the contract event 0x8fe10ae416f22f5e5220b0018a6c1d4ff534d6aa3a471f2a20cb7747fe63e5b9.
//
// Solidity: event FundsAdded(address indexed funder, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) FilterFundsAdded(opts *bind.FilterOpts, funder []common.Address) (*GasMonetizationFundsAddedIterator, error) {

	var funderRule []interface{}
	for _, funderItem := range funder {
		funderRule = append(funderRule, funderItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "FundsAdded", funderRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationFundsAddedIterator{contract: _GasMonetization.contract, event: "FundsAdded", logs: logs, sub: sub}, nil
}

// WatchFundsAdded is a free log subscription operation binding the contract event 0x8fe10ae416f22f5e5220b0018a6c1d4ff534d6aa3a471f2a20cb7747fe63e5b9.
//
// Solidity: event FundsAdded(address indexed funder, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) WatchFundsAdded(opts *bind.WatchOpts, sink chan<- *GasMonetizationFundsAdded, funder []common.Address) (event.Subscription, error) {

	var funderRule []interface{}
	for _, funderItem := range funder {
		funderRule = append(funderRule, funderItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "FundsAdded", funderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationFundsAdded)
				if err := _GasMonetization.contract.UnpackLog(event, "FundsAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFundsAdded is a log parse operation binding the contract event 0x8fe10ae416f22f5e5220b0018a6c1d4ff534d6aa3a471f2a20cb7747fe63e5b9.
//
// Solidity: event FundsAdded(address indexed funder, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) ParseFundsAdded(log types.Log) (*GasMonetizationFundsAdded, error) {
	event := new(GasMonetizationFundsAdded)
	if err := _GasMonetization.contract.UnpackLog(event, "FundsAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationFundsWithdrawnIterator is returned from FilterFundsWithdrawn and is used to iterate over the raw logs and unpacked data for FundsWithdrawn events raised by the GasMonetization contract.
type GasMonetizationFundsWithdrawnIterator struct {
	Event *GasMonetizationFundsWithdrawn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationFundsWithdrawnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationFundsWithdrawn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationFundsWithdrawn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationFundsWithdrawnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationFundsWithdrawnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationFundsWithdrawn represents a FundsWithdrawn event raised by the GasMonetization contract.
type GasMonetizationFundsWithdrawn struct {
	Recipient common.Address
	Amount    *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterFundsWithdrawn is a free log retrieval operation binding the contract event 0xeaff4b37086828766ad3268786972c0cd24259d4c87a80f9d3963a3c3d999b0d.
//
// Solidity: event FundsWithdrawn(address indexed recipient, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) FilterFundsWithdrawn(opts *bind.FilterOpts, recipient []common.Address) (*GasMonetizationFundsWithdrawnIterator, error) {

	var recipientRule []interface{}
	for _, recipientItem := range recipient {
		recipientRule = append(recipientRule, recipientItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "FundsWithdrawn", recipientRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationFundsWithdrawnIterator{contract: _GasMonetization.contract, event: "FundsWithdrawn", logs: logs, sub: sub}, nil
}

// WatchFundsWithdrawn is a free log subscription operation binding the contract event 0xeaff4b37086828766ad3268786972c0cd24259d4c87a80f9d3963a3c3d999b0d.
//
// Solidity: event FundsWithdrawn(address indexed recipient, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) WatchFundsWithdrawn(opts *bind.WatchOpts, sink chan<- *GasMonetizationFundsWithdrawn, recipient []common.Address) (event.Subscription, error) {

	var recipientRule []interface{}
	for _, recipientItem := range recipient {
		recipientRule = append(recipientRule, recipientItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "FundsWithdrawn", recipientRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationFundsWithdrawn)
				if err := _GasMonetization.contract.UnpackLog(event, "FundsWithdrawn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFundsWithdrawn is a log parse operation binding the contract event 0xeaff4b37086828766ad3268786972c0cd24259d4c87a80f9d3963a3c3d999b0d.
//
// Solidity: event FundsWithdrawn(address indexed recipient, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) ParseFundsWithdrawn(log types.Log) (*GasMonetizationFundsWithdrawn, error) {
	event := new(GasMonetizationFundsWithdrawn)
	if err := _GasMonetization.contract.UnpackLog(event, "FundsWithdrawn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectAddedIterator is returned from FilterProjectAdded and is used to iterate over the raw logs and unpacked data for ProjectAdded events raised by the GasMonetization contract.
type GasMonetizationProjectAddedIterator struct {
	Event *GasMonetizationProjectAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectAdded represents a ProjectAdded event raised by the GasMonetization contract.
type GasMonetizationProjectAdded struct {
	Owner       common.Address
	MetadataUri string
	Contracts   []common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterProjectAdded is a free log retrieval operation binding the contract event 0xd67e812e4046dc0df638cf5dd5e6eb8ae397a13d7a9da0090a65742b6fd91d71.
//
// Solidity: event ProjectAdded(address indexed owner, string metadataUri, address[] contracts)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectAdded(opts *bind.FilterOpts, owner []common.Address) (*GasMonetizationProjectAddedIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectAdded", ownerRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectAddedIterator{contract: _GasMonetization.contract, event: "ProjectAdded", logs: logs, sub: sub}, nil
}

// WatchProjectAdded is a free log subscription operation binding the contract event 0xd67e812e4046dc0df638cf5dd5e6eb8ae397a13d7a9da0090a65742b6fd91d71.
//
// Solidity: event ProjectAdded(address indexed owner, string metadataUri, address[] contracts)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectAdded(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectAdded, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectAdded", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectAdded)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectAdded is a log parse operation binding the contract event 0xd67e812e4046dc0df638cf5dd5e6eb8ae397a13d7a9da0090a65742b6fd91d71.
//
// Solidity: event ProjectAdded(address indexed owner, string metadataUri, address[] contracts)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectAdded(log types.Log) (*GasMonetizationProjectAdded, error) {
	event := new(GasMonetizationProjectAdded)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectContractAddedIterator is returned from FilterProjectContractAdded and is used to iterate over the raw logs and unpacked data for ProjectContractAdded events raised by the GasMonetization contract.
type GasMonetizationProjectContractAddedIterator struct {
	Event *GasMonetizationProjectContractAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectContractAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectContractAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectContractAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectContractAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectContractAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectContractAdded represents a ProjectContractAdded event raised by the GasMonetization contract.
type GasMonetizationProjectContractAdded struct {
	Owner           common.Address
	ContractAddress common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterProjectContractAdded is a free log retrieval operation binding the contract event 0x7c1a186c94610c708ec37b603a7b15fc83037e1e1899d0738c534a22407d878f.
//
// Solidity: event ProjectContractAdded(address indexed owner, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectContractAdded(opts *bind.FilterOpts, owner []common.Address, contractAddress []common.Address) (*GasMonetizationProjectContractAddedIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectContractAdded", ownerRule, contractAddressRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectContractAddedIterator{contract: _GasMonetization.contract, event: "ProjectContractAdded", logs: logs, sub: sub}, nil
}

// WatchProjectContractAdded is a free log subscription operation binding the contract event 0x7c1a186c94610c708ec37b603a7b15fc83037e1e1899d0738c534a22407d878f.
//
// Solidity: event ProjectContractAdded(address indexed owner, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectContractAdded(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectContractAdded, owner []common.Address, contractAddress []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectContractAdded", ownerRule, contractAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectContractAdded)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectContractAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectContractAdded is a log parse operation binding the contract event 0x7c1a186c94610c708ec37b603a7b15fc83037e1e1899d0738c534a22407d878f.
//
// Solidity: event ProjectContractAdded(address indexed owner, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectContractAdded(log types.Log) (*GasMonetizationProjectContractAdded, error) {
	event := new(GasMonetizationProjectContractAdded)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectContractAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectContractRemovedIterator is returned from FilterProjectContractRemoved and is used to iterate over the raw logs and unpacked data for ProjectContractRemoved events raised by the GasMonetization contract.
type GasMonetizationProjectContractRemovedIterator struct {
	Event *GasMonetizationProjectContractRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectContractRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectContractRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectContractRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectContractRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectContractRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectContractRemoved represents a ProjectContractRemoved event raised by the GasMonetization contract.
type GasMonetizationProjectContractRemoved struct {
	Owner           common.Address
	ContractAddress common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterProjectContractRemoved is a free log retrieval operation binding the contract event 0x7e34a46ef4198698665986c9eda106ae01cd62c67a1ddd1995516462aa771393.
//
// Solidity: event ProjectContractRemoved(address indexed owner, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectContractRemoved(opts *bind.FilterOpts, owner []common.Address, contractAddress []common.Address) (*GasMonetizationProjectContractRemovedIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectContractRemoved", ownerRule, contractAddressRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectContractRemovedIterator{contract: _GasMonetization.contract, event: "ProjectContractRemoved", logs: logs, sub: sub}, nil
}

// WatchProjectContractRemoved is a free log subscription operation binding the contract event 0x7e34a46ef4198698665986c9eda106ae01cd62c67a1ddd1995516462aa771393.
//
// Solidity: event ProjectContractRemoved(address indexed owner, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectContractRemoved(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectContractRemoved, owner []common.Address, contractAddress []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectContractRemoved", ownerRule, contractAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectContractRemoved)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectContractRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectContractRemoved is a log parse operation binding the contract event 0x7e34a46ef4198698665986c9eda106ae01cd62c67a1ddd1995516462aa771393.
//
// Solidity: event ProjectContractRemoved(address indexed owner, address indexed contractAddress)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectContractRemoved(log types.Log) (*GasMonetizationProjectContractRemoved, error) {
	event := new(GasMonetizationProjectContractRemoved)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectContractRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectContractsSetIterator is returned from FilterProjectContractsSet and is used to iterate over the raw logs and unpacked data for ProjectContractsSet events raised by the GasMonetization contract.
type GasMonetizationProjectContractsSetIterator struct {
	Event *GasMonetizationProjectContractsSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectContractsSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectContractsSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectContractsSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectContractsSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectContractsSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectContractsSet represents a ProjectContractsSet event raised by the GasMonetization contract.
type GasMonetizationProjectContractsSet struct {
	Owner     common.Address
	Contracts []common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterProjectContractsSet is a free log retrieval operation binding the contract event 0xc34d634fde0d2a5084f7dec1eb890b6baa5c469e189c988371c2078d82d8a0b3.
//
// Solidity: event ProjectContractsSet(address indexed owner, address[] contracts)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectContractsSet(opts *bind.FilterOpts, owner []common.Address) (*GasMonetizationProjectContractsSetIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectContractsSet", ownerRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectContractsSetIterator{contract: _GasMonetization.contract, event: "ProjectContractsSet", logs: logs, sub: sub}, nil
}

// WatchProjectContractsSet is a free log subscription operation binding the contract event 0xc34d634fde0d2a5084f7dec1eb890b6baa5c469e189c988371c2078d82d8a0b3.
//
// Solidity: event ProjectContractsSet(address indexed owner, address[] contracts)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectContractsSet(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectContractsSet, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectContractsSet", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectContractsSet)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectContractsSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectContractsSet is a log parse operation binding the contract event 0xc34d634fde0d2a5084f7dec1eb890b6baa5c469e189c988371c2078d82d8a0b3.
//
// Solidity: event ProjectContractsSet(address indexed owner, address[] contracts)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectContractsSet(log types.Log) (*GasMonetizationProjectContractsSet, error) {
	event := new(GasMonetizationProjectContractsSet)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectContractsSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectMetadataUriUpdatedIterator is returned from FilterProjectMetadataUriUpdated and is used to iterate over the raw logs and unpacked data for ProjectMetadataUriUpdated events raised by the GasMonetization contract.
type GasMonetizationProjectMetadataUriUpdatedIterator struct {
	Event *GasMonetizationProjectMetadataUriUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectMetadataUriUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectMetadataUriUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectMetadataUriUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectMetadataUriUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectMetadataUriUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectMetadataUriUpdated represents a ProjectMetadataUriUpdated event raised by the GasMonetization contract.
type GasMonetizationProjectMetadataUriUpdated struct {
	Owner       common.Address
	MetadataUri string
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterProjectMetadataUriUpdated is a free log retrieval operation binding the contract event 0x314a36dc8be566f41b94f41a0a6e3246b42dd5d4169ed073ebea2e3973a13a99.
//
// Solidity: event ProjectMetadataUriUpdated(address indexed owner, string metadataUri)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectMetadataUriUpdated(opts *bind.FilterOpts, owner []common.Address) (*GasMonetizationProjectMetadataUriUpdatedIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectMetadataUriUpdated", ownerRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectMetadataUriUpdatedIterator{contract: _GasMonetization.contract, event: "ProjectMetadataUriUpdated", logs: logs, sub: sub}, nil
}

// WatchProjectMetadataUriUpdated is a free log subscription operation binding the contract event 0x314a36dc8be566f41b94f41a0a6e3246b42dd5d4169ed073ebea2e3973a13a99.
//
// Solidity: event ProjectMetadataUriUpdated(address indexed owner, string metadataUri)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectMetadataUriUpdated(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectMetadataUriUpdated, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectMetadataUriUpdated", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectMetadataUriUpdated)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectMetadataUriUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectMetadataUriUpdated is a log parse operation binding the contract event 0x314a36dc8be566f41b94f41a0a6e3246b42dd5d4169ed073ebea2e3973a13a99.
//
// Solidity: event ProjectMetadataUriUpdated(address indexed owner, string metadataUri)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectMetadataUriUpdated(log types.Log) (*GasMonetizationProjectMetadataUriUpdated, error) {
	event := new(GasMonetizationProjectMetadataUriUpdated)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectMetadataUriUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationProjectRemovedIterator is returned from FilterProjectRemoved and is used to iterate over the raw logs and unpacked data for ProjectRemoved events raised by the GasMonetization contract.
type GasMonetizationProjectRemovedIterator struct {
	Event *GasMonetizationProjectRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationProjectRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationProjectRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationProjectRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationProjectRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationProjectRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationProjectRemoved represents a ProjectRemoved event raised by the GasMonetization contract.
type GasMonetizationProjectRemoved struct {
	Owner common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterProjectRemoved is a free log retrieval operation binding the contract event 0x6c2a7bedc1e997c07f41aff265f8b77df645943615e2b039fb2b1f2be37b67da.
//
// Solidity: event ProjectRemoved(address indexed owner)
func (_GasMonetization *GasMonetizationFilterer) FilterProjectRemoved(opts *bind.FilterOpts, owner []common.Address) (*GasMonetizationProjectRemovedIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "ProjectRemoved", ownerRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationProjectRemovedIterator{contract: _GasMonetization.contract, event: "ProjectRemoved", logs: logs, sub: sub}, nil
}

// WatchProjectRemoved is a free log subscription operation binding the contract event 0x6c2a7bedc1e997c07f41aff265f8b77df645943615e2b039fb2b1f2be37b67da.
//
// Solidity: event ProjectRemoved(address indexed owner)
func (_GasMonetization *GasMonetizationFilterer) WatchProjectRemoved(opts *bind.WatchOpts, sink chan<- *GasMonetizationProjectRemoved, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "ProjectRemoved", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationProjectRemoved)
				if err := _GasMonetization.contract.UnpackLog(event, "ProjectRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProjectRemoved is a log parse operation binding the contract event 0x6c2a7bedc1e997c07f41aff265f8b77df645943615e2b039fb2b1f2be37b67da.
//
// Solidity: event ProjectRemoved(address indexed owner)
func (_GasMonetization *GasMonetizationFilterer) ParseProjectRemoved(log types.Log) (*GasMonetizationProjectRemoved, error) {
	event := new(GasMonetizationProjectRemoved)
	if err := _GasMonetization.contract.UnpackLog(event, "ProjectRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the GasMonetization contract.
type GasMonetizationRoleAdminChangedIterator struct {
	Event *GasMonetizationRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationRoleAdminChanged represents a RoleAdminChanged event raised by the GasMonetization contract.
type GasMonetizationRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_GasMonetization *GasMonetizationFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*GasMonetizationRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationRoleAdminChangedIterator{contract: _GasMonetization.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_GasMonetization *GasMonetizationFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *GasMonetizationRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationRoleAdminChanged)
				if err := _GasMonetization.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_GasMonetization *GasMonetizationFilterer) ParseRoleAdminChanged(log types.Log) (*GasMonetizationRoleAdminChanged, error) {
	event := new(GasMonetizationRoleAdminChanged)
	if err := _GasMonetization.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the GasMonetization contract.
type GasMonetizationRoleGrantedIterator struct {
	Event *GasMonetizationRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationRoleGranted represents a RoleGranted event raised by the GasMonetization contract.
type GasMonetizationRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*GasMonetizationRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationRoleGrantedIterator{contract: _GasMonetization.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *GasMonetizationRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationRoleGranted)
				if err := _GasMonetization.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) ParseRoleGranted(log types.Log) (*GasMonetizationRoleGranted, error) {
	event := new(GasMonetizationRoleGranted)
	if err := _GasMonetization.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the GasMonetization contract.
type GasMonetizationRoleRevokedIterator struct {
	Event *GasMonetizationRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationRoleRevoked represents a RoleRevoked event raised by the GasMonetization contract.
type GasMonetizationRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*GasMonetizationRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationRoleRevokedIterator{contract: _GasMonetization.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *GasMonetizationRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationRoleRevoked)
				if err := _GasMonetization.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_GasMonetization *GasMonetizationFilterer) ParseRoleRevoked(log types.Log) (*GasMonetizationRoleRevoked, error) {
	event := new(GasMonetizationRoleRevoked)
	if err := _GasMonetization.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationWithdrawalBlockLimitUpdatedIterator is returned from FilterWithdrawalBlockLimitUpdated and is used to iterate over the raw logs and unpacked data for WithdrawalBlockLimitUpdated events raised by the GasMonetization contract.
type GasMonetizationWithdrawalBlockLimitUpdatedIterator struct {
	Event *GasMonetizationWithdrawalBlockLimitUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationWithdrawalBlockLimitUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationWithdrawalBlockLimitUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationWithdrawalBlockLimitUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationWithdrawalBlockLimitUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationWithdrawalBlockLimitUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationWithdrawalBlockLimitUpdated represents a WithdrawalBlockLimitUpdated event raised by the GasMonetization contract.
type GasMonetizationWithdrawalBlockLimitUpdated struct {
	Limit *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalBlockLimitUpdated is a free log retrieval operation binding the contract event 0x6d21826867e00c5860f2c41ce6ab260d9b1e0083d852c2fcf38ae8aa983cc4c4.
//
// Solidity: event WithdrawalBlockLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) FilterWithdrawalBlockLimitUpdated(opts *bind.FilterOpts) (*GasMonetizationWithdrawalBlockLimitUpdatedIterator, error) {

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "WithdrawalBlockLimitUpdated")
	if err != nil {
		return nil, err
	}
	return &GasMonetizationWithdrawalBlockLimitUpdatedIterator{contract: _GasMonetization.contract, event: "WithdrawalBlockLimitUpdated", logs: logs, sub: sub}, nil
}

// WatchWithdrawalBlockLimitUpdated is a free log subscription operation binding the contract event 0x6d21826867e00c5860f2c41ce6ab260d9b1e0083d852c2fcf38ae8aa983cc4c4.
//
// Solidity: event WithdrawalBlockLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) WatchWithdrawalBlockLimitUpdated(opts *bind.WatchOpts, sink chan<- *GasMonetizationWithdrawalBlockLimitUpdated) (event.Subscription, error) {

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "WithdrawalBlockLimitUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationWithdrawalBlockLimitUpdated)
				if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalBlockLimitUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalBlockLimitUpdated is a log parse operation binding the contract event 0x6d21826867e00c5860f2c41ce6ab260d9b1e0083d852c2fcf38ae8aa983cc4c4.
//
// Solidity: event WithdrawalBlockLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) ParseWithdrawalBlockLimitUpdated(log types.Log) (*GasMonetizationWithdrawalBlockLimitUpdated, error) {
	event := new(GasMonetizationWithdrawalBlockLimitUpdated)
	if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalBlockLimitUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationWithdrawalCanceledIterator is returned from FilterWithdrawalCanceled and is used to iterate over the raw logs and unpacked data for WithdrawalCanceled events raised by the GasMonetization contract.
type GasMonetizationWithdrawalCanceledIterator struct {
	Event *GasMonetizationWithdrawalCanceled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationWithdrawalCanceledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationWithdrawalCanceled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationWithdrawalCanceled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationWithdrawalCanceledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationWithdrawalCanceledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationWithdrawalCanceled represents a WithdrawalCanceled event raised by the GasMonetization contract.
type GasMonetizationWithdrawalCanceled struct {
	Owner       common.Address
	BlockNumber *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalCanceled is a free log retrieval operation binding the contract event 0xc04d7db2ae23be2ba46893b43d7c4af2fc045905461f3df891e1d6c4d0683ef6.
//
// Solidity: event WithdrawalCanceled(address indexed owner, uint256 blockNumber)
func (_GasMonetization *GasMonetizationFilterer) FilterWithdrawalCanceled(opts *bind.FilterOpts, owner []common.Address) (*GasMonetizationWithdrawalCanceledIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "WithdrawalCanceled", ownerRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationWithdrawalCanceledIterator{contract: _GasMonetization.contract, event: "WithdrawalCanceled", logs: logs, sub: sub}, nil
}

// WatchWithdrawalCanceled is a free log subscription operation binding the contract event 0xc04d7db2ae23be2ba46893b43d7c4af2fc045905461f3df891e1d6c4d0683ef6.
//
// Solidity: event WithdrawalCanceled(address indexed owner, uint256 blockNumber)
func (_GasMonetization *GasMonetizationFilterer) WatchWithdrawalCanceled(opts *bind.WatchOpts, sink chan<- *GasMonetizationWithdrawalCanceled, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "WithdrawalCanceled", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationWithdrawalCanceled)
				if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalCanceled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalCanceled is a log parse operation binding the contract event 0xc04d7db2ae23be2ba46893b43d7c4af2fc045905461f3df891e1d6c4d0683ef6.
//
// Solidity: event WithdrawalCanceled(address indexed owner, uint256 blockNumber)
func (_GasMonetization *GasMonetizationFilterer) ParseWithdrawalCanceled(log types.Log) (*GasMonetizationWithdrawalCanceled, error) {
	event := new(GasMonetizationWithdrawalCanceled)
	if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalCanceled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationWithdrawalCompletedIterator is returned from FilterWithdrawalCompleted and is used to iterate over the raw logs and unpacked data for WithdrawalCompleted events raised by the GasMonetization contract.
type GasMonetizationWithdrawalCompletedIterator struct {
	Event *GasMonetizationWithdrawalCompleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationWithdrawalCompletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationWithdrawalCompleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationWithdrawalCompleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationWithdrawalCompletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationWithdrawalCompletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationWithdrawalCompleted represents a WithdrawalCompleted event raised by the GasMonetization contract.
type GasMonetizationWithdrawalCompleted struct {
	Owner       common.Address
	BlockNumber *big.Int
	Amount      *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalCompleted is a free log retrieval operation binding the contract event 0x35fc39e80f531e18729cd92611935c06db664fc014e88f0b60f14699df88377b.
//
// Solidity: event WithdrawalCompleted(address indexed owner, uint256 blockNumber, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) FilterWithdrawalCompleted(opts *bind.FilterOpts, owner []common.Address) (*GasMonetizationWithdrawalCompletedIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "WithdrawalCompleted", ownerRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationWithdrawalCompletedIterator{contract: _GasMonetization.contract, event: "WithdrawalCompleted", logs: logs, sub: sub}, nil
}

// WatchWithdrawalCompleted is a free log subscription operation binding the contract event 0x35fc39e80f531e18729cd92611935c06db664fc014e88f0b60f14699df88377b.
//
// Solidity: event WithdrawalCompleted(address indexed owner, uint256 blockNumber, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) WatchWithdrawalCompleted(opts *bind.WatchOpts, sink chan<- *GasMonetizationWithdrawalCompleted, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "WithdrawalCompleted", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationWithdrawalCompleted)
				if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalCompleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalCompleted is a log parse operation binding the contract event 0x35fc39e80f531e18729cd92611935c06db664fc014e88f0b60f14699df88377b.
//
// Solidity: event WithdrawalCompleted(address indexed owner, uint256 blockNumber, uint256 amount)
func (_GasMonetization *GasMonetizationFilterer) ParseWithdrawalCompleted(log types.Log) (*GasMonetizationWithdrawalCompleted, error) {
	event := new(GasMonetizationWithdrawalCompleted)
	if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalCompleted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationWithdrawalConfirmationsDeviationUpdatedIterator is returned from FilterWithdrawalConfirmationsDeviationUpdated and is used to iterate over the raw logs and unpacked data for WithdrawalConfirmationsDeviationUpdated events raised by the GasMonetization contract.
type GasMonetizationWithdrawalConfirmationsDeviationUpdatedIterator struct {
	Event *GasMonetizationWithdrawalConfirmationsDeviationUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationWithdrawalConfirmationsDeviationUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationWithdrawalConfirmationsDeviationUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationWithdrawalConfirmationsDeviationUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationWithdrawalConfirmationsDeviationUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationWithdrawalConfirmationsDeviationUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationWithdrawalConfirmationsDeviationUpdated represents a WithdrawalConfirmationsDeviationUpdated event raised by the GasMonetization contract.
type GasMonetizationWithdrawalConfirmationsDeviationUpdated struct {
	Limit *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalConfirmationsDeviationUpdated is a free log retrieval operation binding the contract event 0x8121fd2868e943e2754ac56b5980c9d40f6d1a98048aa242373c30c8d63542d0.
//
// Solidity: event WithdrawalConfirmationsDeviationUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) FilterWithdrawalConfirmationsDeviationUpdated(opts *bind.FilterOpts) (*GasMonetizationWithdrawalConfirmationsDeviationUpdatedIterator, error) {

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "WithdrawalConfirmationsDeviationUpdated")
	if err != nil {
		return nil, err
	}
	return &GasMonetizationWithdrawalConfirmationsDeviationUpdatedIterator{contract: _GasMonetization.contract, event: "WithdrawalConfirmationsDeviationUpdated", logs: logs, sub: sub}, nil
}

// WatchWithdrawalConfirmationsDeviationUpdated is a free log subscription operation binding the contract event 0x8121fd2868e943e2754ac56b5980c9d40f6d1a98048aa242373c30c8d63542d0.
//
// Solidity: event WithdrawalConfirmationsDeviationUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) WatchWithdrawalConfirmationsDeviationUpdated(opts *bind.WatchOpts, sink chan<- *GasMonetizationWithdrawalConfirmationsDeviationUpdated) (event.Subscription, error) {

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "WithdrawalConfirmationsDeviationUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationWithdrawalConfirmationsDeviationUpdated)
				if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalConfirmationsDeviationUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalConfirmationsDeviationUpdated is a log parse operation binding the contract event 0x8121fd2868e943e2754ac56b5980c9d40f6d1a98048aa242373c30c8d63542d0.
//
// Solidity: event WithdrawalConfirmationsDeviationUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) ParseWithdrawalConfirmationsDeviationUpdated(log types.Log) (*GasMonetizationWithdrawalConfirmationsDeviationUpdated, error) {
	event := new(GasMonetizationWithdrawalConfirmationsDeviationUpdated)
	if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalConfirmationsDeviationUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator is returned from FilterWithdrawalConfirmationsLimitUpdated and is used to iterate over the raw logs and unpacked data for WithdrawalConfirmationsLimitUpdated events raised by the GasMonetization contract.
type GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator struct {
	Event *GasMonetizationWithdrawalConfirmationsLimitUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationWithdrawalConfirmationsLimitUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationWithdrawalConfirmationsLimitUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationWithdrawalConfirmationsLimitUpdated represents a WithdrawalConfirmationsLimitUpdated event raised by the GasMonetization contract.
type GasMonetizationWithdrawalConfirmationsLimitUpdated struct {
	Limit *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalConfirmationsLimitUpdated is a free log retrieval operation binding the contract event 0x00209f2b72d564f415b7b96764fdee7ecf5f45854745e582a224b9a1a1ba1ddc.
//
// Solidity: event WithdrawalConfirmationsLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) FilterWithdrawalConfirmationsLimitUpdated(opts *bind.FilterOpts) (*GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator, error) {

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "WithdrawalConfirmationsLimitUpdated")
	if err != nil {
		return nil, err
	}
	return &GasMonetizationWithdrawalConfirmationsLimitUpdatedIterator{contract: _GasMonetization.contract, event: "WithdrawalConfirmationsLimitUpdated", logs: logs, sub: sub}, nil
}

// WatchWithdrawalConfirmationsLimitUpdated is a free log subscription operation binding the contract event 0x00209f2b72d564f415b7b96764fdee7ecf5f45854745e582a224b9a1a1ba1ddc.
//
// Solidity: event WithdrawalConfirmationsLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) WatchWithdrawalConfirmationsLimitUpdated(opts *bind.WatchOpts, sink chan<- *GasMonetizationWithdrawalConfirmationsLimitUpdated) (event.Subscription, error) {

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "WithdrawalConfirmationsLimitUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationWithdrawalConfirmationsLimitUpdated)
				if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalConfirmationsLimitUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalConfirmationsLimitUpdated is a log parse operation binding the contract event 0x00209f2b72d564f415b7b96764fdee7ecf5f45854745e582a224b9a1a1ba1ddc.
//
// Solidity: event WithdrawalConfirmationsLimitUpdated(uint256 limit)
func (_GasMonetization *GasMonetizationFilterer) ParseWithdrawalConfirmationsLimitUpdated(log types.Log) (*GasMonetizationWithdrawalConfirmationsLimitUpdated, error) {
	event := new(GasMonetizationWithdrawalConfirmationsLimitUpdated)
	if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalConfirmationsLimitUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasMonetizationWithdrawalRequestedIterator is returned from FilterWithdrawalRequested and is used to iterate over the raw logs and unpacked data for WithdrawalRequested events raised by the GasMonetization contract.
type GasMonetizationWithdrawalRequestedIterator struct {
	Event *GasMonetizationWithdrawalRequested // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasMonetizationWithdrawalRequestedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasMonetizationWithdrawalRequested)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasMonetizationWithdrawalRequested)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasMonetizationWithdrawalRequestedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasMonetizationWithdrawalRequestedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasMonetizationWithdrawalRequested represents a WithdrawalRequested event raised by the GasMonetization contract.
type GasMonetizationWithdrawalRequested struct {
	Owner       common.Address
	BlockNumber *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalRequested is a free log retrieval operation binding the contract event 0xe670e4e82118d22a1f9ee18920455ebc958bae26a90a05d31d3378788b1b0e44.
//
// Solidity: event WithdrawalRequested(address indexed owner, uint256 blockNumber)
func (_GasMonetization *GasMonetizationFilterer) FilterWithdrawalRequested(opts *bind.FilterOpts, owner []common.Address) (*GasMonetizationWithdrawalRequestedIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.FilterLogs(opts, "WithdrawalRequested", ownerRule)
	if err != nil {
		return nil, err
	}
	return &GasMonetizationWithdrawalRequestedIterator{contract: _GasMonetization.contract, event: "WithdrawalRequested", logs: logs, sub: sub}, nil
}

// WatchWithdrawalRequested is a free log subscription operation binding the contract event 0xe670e4e82118d22a1f9ee18920455ebc958bae26a90a05d31d3378788b1b0e44.
//
// Solidity: event WithdrawalRequested(address indexed owner, uint256 blockNumber)
func (_GasMonetization *GasMonetizationFilterer) WatchWithdrawalRequested(opts *bind.WatchOpts, sink chan<- *GasMonetizationWithdrawalRequested, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _GasMonetization.contract.WatchLogs(opts, "WithdrawalRequested", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasMonetizationWithdrawalRequested)
				if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalRequested", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalRequested is a log parse operation binding the contract event 0xe670e4e82118d22a1f9ee18920455ebc958bae26a90a05d31d3378788b1b0e44.
//
// Solidity: event WithdrawalRequested(address indexed owner, uint256 blockNumber)
func (_GasMonetization *GasMonetizationFilterer) ParseWithdrawalRequested(log types.Log) (*GasMonetizationWithdrawalRequested, error) {
	event := new(GasMonetizationWithdrawalRequested)
	if err := _GasMonetization.contract.UnpackLog(event, "WithdrawalRequested", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
